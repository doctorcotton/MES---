# è‡ªåŠ¨å¸ƒå±€ç®—æ³•è¯¦ç»†æ–‡æ¡£

## ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [å®ç°çŠ¶æ€æ€»è§ˆ](#å®ç°çŠ¶æ€æ€»è§ˆ)
3. [æŠ€æœ¯è·¯çº¿](#æŠ€æœ¯è·¯çº¿)
4. [ç®—æ³•æ¶æ„](#ç®—æ³•æ¶æ„)
5. [æ ¸å¿ƒç®—æ³•è¯¦è§£](#æ ¸å¿ƒç®—æ³•è¯¦è§£)
6. [èŠ‚ç‚¹å°ºå¯¸è®¡ç®—](#èŠ‚ç‚¹å°ºå¯¸è®¡ç®—)
7. [ç²¾ç¡®é«˜åº¦è®¡ç®—](#ç²¾ç¡®é«˜åº¦è®¡ç®—)
8. [è°ƒè¯•æ¨¡å¼](#è°ƒè¯•æ¨¡å¼)
9. [æ•°æ®å­˜å‚¨æ ¼å¼](#æ•°æ®å­˜å‚¨æ ¼å¼)
10. [ä»£ç å®ç°ç»†èŠ‚](#ä»£ç å®ç°ç»†èŠ‚)
11. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
12. [å®ç°çŠ¶æ€è¯´æ˜](#å®ç°çŠ¶æ€è¯´æ˜)

---

## æ¦‚è¿°

æœ¬ç³»ç»Ÿå®ç°äº†ä¸€ä¸ªæ™ºèƒ½çš„å·¥è‰ºæµç¨‹å›¾è‡ªåŠ¨å¸ƒå±€ç®—æ³•ï¼Œç”¨äºè‡ªåŠ¨è®¡ç®—å’Œæ’åˆ—é…æ–¹å·¥è‰ºæµç¨‹å›¾ä¸­çš„èŠ‚ç‚¹ä½ç½®ã€‚ç®—æ³•é‡‡ç”¨**å·¥è‰ºæ®µè¯†åˆ« + åˆ†æ®µå¸ƒå±€**çš„ç­–ç•¥ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„å¹¶è¡Œ-ä¸²è¡Œæ··åˆæµç¨‹ï¼Œç¡®ä¿è¿çº¿é•¿åº¦å‡åŒ€ã€è§†è§‰ç¾è§‚ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å·¥è‰ºæ®µè‡ªåŠ¨è¯†åˆ«**ï¼šè‡ªåŠ¨è¯†åˆ«å¹¶è¡Œå·¥è‰ºæ®µå’Œä¸²è¡Œå·¥è‰ºæ®µ
- âœ… **åˆ†æ®µå¸ƒå±€è®¡ç®—**ï¼šå¹¶è¡Œæ®µå’Œä¸²è¡Œæ®µé‡‡ç”¨ä¸åŒçš„å¸ƒå±€ç­–ç•¥
- âœ… **å›ºå®šè¿çº¿é•¿åº¦**ï¼šç¡®ä¿æ‰€æœ‰è¿çº¿é•¿åº¦ç»Ÿä¸€ï¼ˆç›®æ ‡å€¼ï¼š120pxï¼‰
- âš ï¸ **èŠ‚ç‚¹å°ºå¯¸è®¡ç®—**ï¼šä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡çš„çœŸå®å°ºå¯¸ï¼ˆé Canvas APIï¼‰
- âœ… **åˆ†æ¡£å®½åº¦ç­–ç•¥**ï¼šæ ¹æ®è¾“å…¥æ•°é‡åŠ¨æ€è®¡ç®—èŠ‚ç‚¹å®½åº¦ï¼ˆåœ¨ CustomNode ä¸­å®ç°ï¼‰
- âœ… **æ°´å¹³å¯¹é½ä¼˜åŒ–**ï¼šåŸºäº `displayOrder` çš„æ°´å¹³å¯¹é½
- âœ… **æ±‡èšç‚¹æ™ºèƒ½å±…ä¸­**ï¼šå¤šè¾“å…¥èŠ‚ç‚¹çš„åŠ æƒå±…ä¸­ç®—æ³•
- âœ… **è°ƒè¯•æ¨¡å¼**ï¼šå¯è§†åŒ–æ˜¾ç¤ºè¿çº¿é•¿åº¦å’Œè¯¯å·®ï¼Œå¿«é€Ÿå®šä½å¸ƒå±€é—®é¢˜

---

## å®ç°çŠ¶æ€æ€»è§ˆ

| åŠŸèƒ½æ¨¡å— | å®ç°çŠ¶æ€ | è¯´æ˜ |
|---------|---------|------|
| **å·¥è‰ºæ®µè¯†åˆ«** | âœ… å·²å®ç° | `segmentIdentifier.ts` - ä½¿ç”¨ DFS ç®—æ³•è¯†åˆ«å¹¶è¡Œ/ä¸²è¡Œæ®µ |
| **å¹¶è¡Œæ®µå¸ƒå±€** | âœ… å·²å®ç° | `layoutParallelSegments` - æŒ‰å·¥è‰ºç±»å‹åˆ†ç»„å¯¹é½ |
| **èƒå–ç±»è‡ªé€‚åº”å‹ç¼©** | âœ… å·²å®ç° | `calculateExtractionEdgeLength` - èŠ‚ç‚¹è¶Šå¤šé—´è·è¶Šå° |
| **ä¸²è¡Œæ®µå¸ƒå±€** | âœ… å·²å®ç° | `layoutSerialSegments` - ä»æ±‡èšç‚¹å‘ä¸‹æ’åˆ— |
| **æ±‡èšç‚¹Yåæ ‡è®¡ç®—** | âœ… å·²å®ç° | `calculateConvergenceY` - æ”¯æŒ max/weighted/median ç­–ç•¥ |
| **æ±‡èšç‚¹Xåæ ‡å±…ä¸­** | âœ… å·²å®ç° | åŠ æƒè´¨å¿ƒç®—æ³•ï¼ŒåŸºäºå­æ ‘è§„æ¨¡çš„**å¹³æ–¹æ ¹** |
| **å¸ƒå±€å¸é™„æœºåˆ¶** | âœ… å·²å®ç° | æ±‡èšç‚¹è‡ªåŠ¨å¸é™„åˆ°å…¥è¾¹æºèŠ‚ç‚¹Xåæ ‡ |
| **åœ†è§’å¯è¡Œæ€§æ£€æŸ¥** | âœ… å·²å®ç° | ç¡®ä¿è¿çº¿æœ‰è¶³å¤Ÿæ°´å¹³ç©ºé—´ç”»åœ†è§’ |
| **åŸºäº displayOrder çš„æ°´å¹³å¸ƒå±€** | âœ… å·²å®ç° | æ¯ä¸ª Process åˆ†é…ä¸€ä¸ªæ°´å¹³è½¦é“ |
| **åˆ†æ¡£å®½åº¦è®¡ç®—** | âœ… å·²å®ç° | `CustomNode.tsx` ä¸­çš„ `getTieredWidth` å‡½æ•° |
| **èŠ‚ç‚¹å°ºå¯¸è·å–** | âœ… å·²å®ç° | ä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡çš„ `node.width` å’Œ `node.height` |
| **æµ‹é‡é‡è¯•æœºåˆ¶** | âœ… å·²å®ç° | æœ€å¤šé‡è¯•5æ¬¡ï¼Œé¿å…ä½¿ç”¨æœªæµ‹é‡çš„å°ºå¯¸ |
| **è°ƒè¯•æ¨¡å¼** | âœ… å·²å®ç° | `DebugOverlay.tsx` å’Œ `DebugStatsPanel.tsx` |

---

## æŠ€æœ¯è·¯çº¿

### æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|
| **React Flow** | 11.11.0 | æµç¨‹å›¾æ¸²æŸ“å¼•æ“ï¼ˆæä¾›èŠ‚ç‚¹å°ºå¯¸è‡ªåŠ¨æµ‹é‡ï¼‰ |
| **TypeScript** | 5.2.2 | ç±»å‹å®‰å…¨ |
| **Zustand** | 4.5.0 | çŠ¶æ€ç®¡ç† |
| **React Hooks** | - | å“åº”å¼å¸ƒå±€è®¡ç®—ï¼ˆuseLayoutEffect, useNodesInitializedï¼‰ |

**æ³¨æ„**ï¼šæ–‡æ¡£ä¸­æåˆ°çš„ Dagre åº“æœªåœ¨ä»£ç ä¸­ä½¿ç”¨ã€‚æ°´å¹³å¸ƒå±€ç›´æ¥åŸºäº `displayOrder` è®¡ç®—ï¼Œä¸ä¾èµ–å›¾å½¢å¸ƒå±€ç®—æ³•åº“ã€‚

### ç®—æ³•æµç¨‹

```mermaid
flowchart TD
    A[å¼€å§‹å¸ƒå±€è®¡ç®—] --> B[ç­‰å¾…èŠ‚ç‚¹åˆå§‹åŒ–]
    B --> C{èŠ‚ç‚¹å°ºå¯¸å·²æµ‹é‡?}
    C -->|å¦| B
    C -->|æ˜¯| D[æ”¶é›†èŠ‚ç‚¹çœŸå®å°ºå¯¸]
    D --> E[è¯†åˆ«å·¥è‰ºæ®µ]
    E --> F[åŸºäºdisplayOrderåˆ†é…Xåæ ‡]
    F --> G[å¸ƒå±€å¹¶è¡Œæ®µYåæ ‡]
    G --> H[è®¡ç®—æ±‡èšç‚¹Yåæ ‡]
    H --> I[è®¡ç®—æ±‡èšç‚¹Xåæ ‡åŠ æƒå±…ä¸­]
    I --> J[å¸ƒå±€ä¸²è¡Œæ®µYåæ ‡]
    J --> K[åº”ç”¨Xåæ ‡åˆ°ä¸²è¡Œæ®µ]
    K --> L[è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡]
    L --> M[æ›´æ–°èŠ‚ç‚¹ä½ç½®]
    M --> N[è°ƒç”¨fitView]
    N --> O[ç»“æŸ]
```

---

## ç®—æ³•æ¶æ„

### æ¨¡å—åˆ’åˆ†

```
src/components/graph/
â”œâ”€â”€ LayoutController.tsx      # ä¸»å¸ƒå±€æ§åˆ¶å™¨ï¼ˆå…¥å£ï¼ŒHeadless Componentï¼‰
â”œâ”€â”€ RecipeFlow.tsx            # React Flow ç»„ä»¶ï¼ˆé›†æˆå¸ƒå±€æ§åˆ¶å™¨ï¼‰
â”œâ”€â”€ DebugOverlay.tsx          # è°ƒè¯•å åŠ å±‚ç»„ä»¶
â””â”€â”€ DebugStatsPanel.tsx       # è°ƒè¯•ç»Ÿè®¡é¢æ¿

src/hooks/
â”œâ”€â”€ segmentIdentifier.ts      # å·¥è‰ºæ®µè¯†åˆ«ç®—æ³•
â””â”€â”€ segmentLayoutCalculator.ts # åˆ†æ®µå¸ƒå±€è®¡ç®—å™¨

src/components/graph/
â””â”€â”€ CustomNode.tsx            # è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶ï¼ˆåŒ…å«åˆ†æ¡£å®½åº¦è®¡ç®—ï¼‰
```

### æ•°æ®æµ

```mermaid
sequenceDiagram
    participant RecipeFlow as RecipeFlow
    participant LayoutCtrl as LayoutController
    participant ReactFlow as React Flow
    participant Identifier as segmentIdentifier
    participant Calculator as segmentLayoutCalculator

    RecipeFlow->>LayoutCtrl: å†…å®¹å˜åŒ–è§¦å‘å¸ƒå±€
    LayoutCtrl->>ReactFlow: ç­‰å¾…èŠ‚ç‚¹åˆå§‹åŒ–ï¼ˆuseNodesInitializedï¼‰
    ReactFlow-->>LayoutCtrl: èŠ‚ç‚¹å°ºå¯¸å·²æµ‹é‡ï¼ˆnode.width, node.heightï¼‰
    LayoutCtrl->>Identifier: è¯†åˆ«å·¥è‰ºæ®µ
    Identifier-->>LayoutCtrl: å¹¶è¡Œæ®µ + ä¸²è¡Œæ®µ
    LayoutCtrl->>Calculator: å¸ƒå±€å¹¶è¡Œæ®µ
    Calculator-->>LayoutCtrl: å¹¶è¡Œæ®µYåæ ‡
    LayoutCtrl->>Calculator: è®¡ç®—æ±‡èšç‚¹Y
    Calculator-->>LayoutCtrl: æ±‡èšç‚¹Yåæ ‡
    LayoutCtrl->>LayoutCtrl: åŸºäº displayOrder åˆ†é…Xåæ ‡
    LayoutCtrl->>LayoutCtrl: è®¡ç®—æ±‡èšç‚¹Xåæ ‡ï¼ˆåŠ æƒå±…ä¸­ï¼‰
    LayoutCtrl->>Calculator: å¸ƒå±€ä¸²è¡Œæ®µ
    Calculator-->>LayoutCtrl: ä¸²è¡Œæ®µYåæ ‡
    LayoutCtrl->>LayoutCtrl: è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡
    LayoutCtrl->>ReactFlow: æ›´æ–°èŠ‚ç‚¹ä½ç½®ï¼ˆsetNodesï¼‰
    LayoutCtrl->>ReactFlow: è°ƒç”¨ fitView
    LayoutCtrl->>RecipeFlow: é€šçŸ¥å¸ƒå±€å®Œæˆ
```

### å…³é”®è®¾è®¡å†³ç­–

1. **Headless Component æ¨¡å¼**ï¼š`LayoutController` ä¸æ¸²æŸ“ä»»ä½• UIï¼Œä»…è´Ÿè´£å¸ƒå±€è®¡ç®—
2. **ç­‰å¾…èŠ‚ç‚¹å°ºå¯¸æµ‹é‡**ï¼šä½¿ç”¨ React Flow çš„ `useNodesInitialized` ç¡®ä¿èŠ‚ç‚¹å°ºå¯¸å·²æµ‹é‡
3. **åæ ‡ç³»ç»Ÿ**ï¼šå†…éƒ¨ä½¿ç”¨ä¸­å¿ƒç‚¹åæ ‡è®¡ç®—ï¼Œæœ€åè½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆReact Flow è¦æ±‚ï¼‰
4. **å¸ƒå±€è§¦å‘**ï¼šåŸºäºå†…å®¹å˜åŒ–è§¦å‘å™¨ï¼ˆ`layoutTrigger`ï¼‰ï¼ŒåŒ…å«å·¥è‰ºæ®µIDã€å­æ­¥éª¤IDã€å±•å¼€çŠ¶æ€

---

## æ ¸å¿ƒç®—æ³•è¯¦è§£

### 1. å·¥è‰ºæ®µè¯†åˆ«ç®—æ³• (`segmentIdentifier.ts`)

#### ç®—æ³•åŸç†

å·¥è‰ºæ®µè¯†åˆ«é‡‡ç”¨**æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰**ç­–ç•¥ï¼Œä»èµ·ç‚¹èŠ‚ç‚¹å¼€å§‹éå†ï¼Œç›´åˆ°é‡åˆ°æ±‡èšç‚¹æˆ–ç»ˆç‚¹ã€‚

#### è¯†åˆ«è§„åˆ™

1. **èµ·ç‚¹èŠ‚ç‚¹**ï¼šå…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹
2. **æ±‡èšç‚¹**ï¼šå…¥åº¦ > 1 çš„èŠ‚ç‚¹ï¼ˆå¤šä¸ªåˆ†æ”¯æ±‡èšï¼‰
3. **å¹¶è¡Œå·¥è‰ºæ®µ**ï¼šä»èµ·ç‚¹åˆ°æ±‡èšç‚¹ä¹‹é—´çš„è·¯å¾„
4. **ä¸²è¡Œå·¥è‰ºæ®µ**ï¼šæ±‡èšç‚¹ä¹‹åçš„è¿ç»­èŠ‚ç‚¹åºåˆ—

#### å®Œæ•´å®ç°ä»£ç 

```typescript
export function identifyProcessSegments(
  nodes: FlowNode[],
  edges: RecipeEdge[]
): SegmentIdentificationResult {
  // 1. æ„å»ºå›¾ç»“æ„ï¼ˆé‚»æ¥è¡¨ï¼‰
  const nodeMap = new Map<string, FlowNode>();
  nodes.forEach(node => nodeMap.set(node.id, node));

  const outgoingEdges = new Map<string, RecipeEdge[]>();
  const incomingEdges = new Map<string, RecipeEdge[]>();

  edges.forEach(edge => {
    if (!outgoingEdges.has(edge.source)) {
      outgoingEdges.set(edge.source, []);
    }
    outgoingEdges.get(edge.source)!.push(edge);

    if (!incomingEdges.has(edge.target)) {
      incomingEdges.set(edge.target, []);
    }
    incomingEdges.get(edge.target)!.push(edge);
  });

  // 2. æ‰¾åˆ°æ‰€æœ‰èµ·ç‚¹èŠ‚ç‚¹ï¼ˆå…¥åº¦ä¸º0ï¼‰
  const startNodes = nodes.filter(node => {
    const incoming = incomingEdges.get(node.id) || [];
    return incoming.length === 0;
  });

  // 3. æ‰¾åˆ°æ±‡èšç‚¹ï¼ˆå…¥åº¦ > 1 çš„èŠ‚ç‚¹ï¼‰
  const convergenceNodes = nodes.filter(node => {
    const incoming = incomingEdges.get(node.id) || [];
    return incoming.length > 1;
  });

  // å¦‚æœåªæœ‰ä¸€ä¸ªæ±‡èšç‚¹ï¼Œä½¿ç”¨å®ƒï¼›å¦åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ª
  const convergenceNode = convergenceNodes.length > 0 ? convergenceNodes[0] : null;

  // 4. ä»æ¯ä¸ªèµ·ç‚¹å¼€å§‹DFSï¼Œæ„å»ºå¹¶è¡Œå·¥è‰ºæ®µ
  const parallelSegments: ProcessSegment[] = [];
  const visited = new Set<string>();

  startNodes.forEach((startNode, index) => {
    if (visited.has(startNode.id)) return;

    const segmentNodes: FlowNode[] = [];
    const segmentNodeIds = new Set<string>();

    // DFSéå†ï¼Œç›´åˆ°é‡åˆ°æ±‡èšç‚¹æˆ–ç»ˆç‚¹
    function dfs(currentNodeId: string): void {
      if (visited.has(currentNodeId)) return;
      if (segmentNodeIds.has(currentNodeId)) return; // é˜²æ­¢å¾ªç¯

      const currentNode = nodeMap.get(currentNodeId);
      if (!currentNode) return;

      // å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯æ±‡èšç‚¹ï¼Œåœæ­¢éå†
      if (convergenceNode && currentNodeId === convergenceNode.id) {
        return;
      }

      segmentNodes.push(currentNode);
      segmentNodeIds.add(currentNodeId);
      visited.add(currentNodeId);

      // ç»§ç»­éå†å‡ºè¾¹
      const outgoing = outgoingEdges.get(currentNodeId) || [];
      for (const edge of outgoing) {
        const targetId = edge.target;
        
        // å¦‚æœç›®æ ‡èŠ‚ç‚¹æ˜¯æ±‡èšç‚¹ï¼Œåœæ­¢éå†
        if (convergenceNode && targetId === convergenceNode.id) {
          continue;
        }

        // å¦‚æœç›®æ ‡èŠ‚ç‚¹å·²ç»æœ‰å…¥è¾¹ï¼ˆä¸”ä¸æ˜¯å½“å‰è¾¹ï¼‰ï¼Œè¯´æ˜æ˜¯æ±‡èšç‚¹ï¼Œåœæ­¢
        const targetIncoming = incomingEdges.get(targetId) || [];
        if (targetIncoming.length > 1) {
          continue;
        }

        dfs(targetId);
      }
    }

    dfs(startNode.id);

    if (segmentNodes.length > 0) {
      parallelSegments.push({
        id: `parallel-segment-${index}`,
        nodes: segmentNodes,
        isParallel: true,
        startNodeId: segmentNodes[0].id,
        endNodeId: segmentNodes[segmentNodes.length - 1].id,
      });
    }
  });

  // 5. è¯†åˆ«ä¸²è¡Œå·¥è‰ºæ®µï¼ˆæ±‡èšç‚¹ä¹‹åçš„èŠ‚ç‚¹ï¼‰
  const serialSegments: ProcessSegment[] = [];
  
  if (convergenceNode) {
    const serialNodes: FlowNode[] = [convergenceNode];
    const serialNodeIds = new Set<string>([convergenceNode.id]);

    // ä»æ±‡èšç‚¹å¼€å§‹ï¼Œæ‰¾åˆ°æ‰€æœ‰åç»­èŠ‚ç‚¹
    function collectSerialNodes(nodeId: string): void {
      const outgoing = outgoingEdges.get(nodeId) || [];
      
      for (const edge of outgoing) {
        const targetId = edge.target;
        
        if (serialNodeIds.has(targetId)) continue;

        const targetNode = nodeMap.get(targetId);
        if (!targetNode) continue;

        // å¦‚æœç›®æ ‡èŠ‚ç‚¹æœ‰å¤šä¸ªå…¥è¾¹ï¼Œè¯´æ˜æ˜¯å¦ä¸€ä¸ªæ±‡èšç‚¹ï¼Œåœæ­¢
        const targetIncoming = incomingEdges.get(targetId) || [];
        if (targetIncoming.length > 1 && targetId !== convergenceNode.id) {
          continue;
        }

        serialNodes.push(targetNode);
        serialNodeIds.add(targetId);
        collectSerialNodes(targetId);
      }
    }

    collectSerialNodes(convergenceNode.id);

    // å°†ä¸²è¡ŒèŠ‚ç‚¹åˆ†ç»„ä¸ºå·¥è‰ºæ®µï¼ˆè¿ç»­çš„èŠ‚ç‚¹ä¸ºä¸€ä¸ªæ®µï¼‰
    if (serialNodes.length > 1) {
      let currentSegment: FlowNode[] = [serialNodes[0]];
      
      for (let i = 1; i < serialNodes.length; i++) {
        const prevNode = serialNodes[i - 1];
        const currentNode = serialNodes[i];
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç›´æ¥è¿æ¥
        const hasDirectEdge = edges.some(
          e => e.source === prevNode.id && e.target === currentNode.id
        );

        if (hasDirectEdge) {
          currentSegment.push(currentNode);
        } else {
          // å¼€å§‹æ–°æ®µ
          if (currentSegment.length > 0) {
            serialSegments.push({
              id: `serial-segment-${serialSegments.length}`,
              nodes: currentSegment,
              isParallel: false,
              startNodeId: currentSegment[0].id,
              endNodeId: currentSegment[currentSegment.length - 1].id,
            });
          }
          currentSegment = [currentNode];
        }
      }

      // æ·»åŠ æœ€åä¸€ä¸ªæ®µ
      if (currentSegment.length > 0) {
        serialSegments.push({
          id: `serial-segment-${serialSegments.length}`,
          nodes: currentSegment,
          isParallel: false,
          startNodeId: currentSegment[0].id,
          endNodeId: currentSegment[currentSegment.length - 1].id,
        });
      }
    }
  }

  return {
    parallelSegments,
    convergenceNode,
    serialSegments,
  };
}
```

#### è¯†åˆ«ç»“æœç»“æ„

```typescript
interface ProcessSegment {
  id: string;              // æ®µIDï¼Œå¦‚ "parallel-segment-0"
  nodes: FlowNode[];       // è¯¥æ®µçš„æ‰€æœ‰èŠ‚ç‚¹
  isParallel: boolean;     // æ˜¯å¦åœ¨å¹¶è¡ŒåŒºåŸŸ
  startNodeId: string;     // èµ·å§‹èŠ‚ç‚¹ID
  endNodeId: string;       // ç»“æŸèŠ‚ç‚¹ID
}
```

---

### 2. åˆ†æ®µå¸ƒå±€è®¡ç®—å™¨ (`segmentLayoutCalculator.ts`)

#### 2.1 å¹¶è¡Œæ®µå¸ƒå±€

**ç›®æ ‡**ï¼šå®ç°æ™ºèƒ½çš„å¹¶è¡Œæ®µå¸ƒå±€ï¼Œå…·å¤‡ä»¥ä¸‹ç‰¹æ€§ï¼š

- **æŒ‰å·¥è‰ºç±»å‹åˆ†ç»„å¯¹é½**ï¼šåŒç±»å‹æ®µçš„èµ·ç‚¹Yåæ ‡ç›¸åŒ
- **ç»„é—´Yåç§»**ï¼šçŸ­ç±»å‹æ•´ä½“ä¸‹ç§»ï¼Œè®©å„ç»„æœ«ç«¯æ›´æ¥è¿‘
- **èƒå–ç±»è‡ªé€‚åº”å‹ç¼©**ï¼šå­æ­¥éª¤è¶Šå¤šï¼Œæ®µå†…é—´è·è¶Šå°

```typescript
export function layoutParallelSegments(
  segments: ProcessSegment[],
  nodeHeights: Record<string, number>,
  config: ParallelLayoutConfig
): Record<string, number> {
  const nodeYPositions: Record<string, number> = {};

  // æ­¥éª¤1: æŒ‰å·¥è‰ºç±»å‹åˆ†ç»„
  const segmentsByType = new Map<ProcessType | 'unknown', ProcessSegment[]>();
  segments.forEach(segment => {
    const segmentType = getSegmentType(segment);
    if (!segmentsByType.has(segmentType)) {
      segmentsByType.set(segmentType, []);
    }
    segmentsByType.get(segmentType)!.push(segment);
  });

  // æ­¥éª¤2: è®¡ç®—æ¯ä¸ªæ®µçš„ç›¸å¯¹å¸ƒå±€å’Œè¾¹è·
  interface SegmentLayoutInfo {
    segment: ProcessSegment;
    segmentType: ProcessType | 'unknown';
    edgeLength: number;
    relativePositions: Record<string, number>;
    lastNodeBottom: number;
  }

  const segmentLayouts: SegmentLayoutInfo[] = [];
  
  segments.forEach(segment => {
    const segmentType = getSegmentType(segment);
    const nodeCount = segment.nodes.length;
    
    // è®¡ç®—è¾¹è·ï¼šèƒå–ç±»ä½¿ç”¨è‡ªé€‚åº”å…¬å¼ï¼Œå…¶ä»–ç±»å‹ä½¿ç”¨å›ºå®šå€¼
    let edgeLength: number;
    if (segmentType === ProcessTypes.EXTRACTION) {
      edgeLength = calculateExtractionEdgeLength(nodeCount, config.targetEdgeLength);
    } else {
      edgeLength = config.targetEdgeLength;
    }
    
    // è®¡ç®—ç›¸å¯¹å¸ƒå±€ï¼ˆå‡è®¾ startY=0ï¼‰
    const { relativePositions, lastNodeBottom } = calculateRelativeLayout(
      segment,
      nodeHeights,
      edgeLength
    );
    
    segmentLayouts.push({ segment, segmentType, edgeLength, relativePositions, lastNodeBottom });
  });

  // æ­¥éª¤3: è®¡ç®—æ¯ä¸ªç±»å‹ç»„çš„ spanï¼ˆç»„å†…æœ€å¤§ lastNodeBottomï¼‰
  const groupSpans = new Map<ProcessType | 'unknown', number>();
  segmentsByType.forEach((typeSegments, type) => {
    const maxSpan = Math.max(
      ...typeSegments.map(seg => {
        const layout = segmentLayouts.find(l => l.segment.id === seg.id);
        return layout ? layout.lastNodeBottom : 0;
      })
    );
    groupSpans.set(type, maxSpan);
  });

  // æ­¥éª¤4: è®¡ç®—å…¨å±€æœ€å¤§ span
  const globalMaxSpan = Math.max(...Array.from(groupSpans.values()));

  // æ­¥éª¤5: ç¡®å®šæ¯ç»„ startYï¼ˆç»„å†…å¤´éƒ¨å¯¹é½ï¼Œç»„é—´åç§»è®©æœ«ç«¯æ¥è¿‘ï¼‰
  const groupStartYs = new Map<ProcessType | 'unknown', number>();
  const baseStartY = config.initialY;
  
  segmentsByType.forEach((_typeSegments, type) => {
    const groupSpan = groupSpans.get(type) || 0;
    // çŸ­ç»„ä¸‹ç§»ï¼šgroupStartY = baseStartY + (globalMaxSpan - groupSpan)
    const groupStartY = baseStartY + (globalMaxSpan - groupSpan);
    groupStartYs.set(type, groupStartY);
  });

  // æ­¥éª¤6: åº”ç”¨åç§»ï¼Œå†™å…¥æœ€ç»ˆä½ç½®
  segmentLayouts.forEach(({ segment, segmentType, relativePositions }) => {
    const groupStartY = groupStartYs.get(segmentType) || baseStartY;
    
    segment.nodes.forEach(node => {
      const relativeY = relativePositions[node.id];
      nodeYPositions[node.id] = groupStartY + relativeY;
    });
  });

  return nodeYPositions;
}
```

#### 2.1.1 èƒå–ç±»è‡ªé€‚åº”è¾¹è·è®¡ç®—

èƒå–ç±»å·¥è‰ºæ®µé€šå¸¸åŒ…å«è¾ƒå¤šå­æ­¥éª¤ï¼Œä½¿ç”¨è‡ªé€‚åº”å…¬å¼å‹ç¼©é—´è·ï¼š

```typescript
/**
 * è®¡ç®—èƒå–æ®µçš„è‡ªé€‚åº”è¾¹è·é•¿åº¦
 * 
 * å…¬å¼: edgeLen(n) = clamp(base * s * sqrt(3 / max(n, 3)), minEdge, base)
 * 
 * @param nodeCount æ®µå†…èŠ‚ç‚¹æ•°é‡
 * @param base åŸºç¡€è¾¹è·ï¼ˆé»˜è®¤ 120ï¼‰
 * @param scale ç¼©æ”¾å› å­ï¼ˆé»˜è®¤ 0.96ï¼Œè®© n=4 æ—¶çº¦ç­‰äº 100ï¼‰
 * @param minEdge æœ€å°è¾¹è·ï¼ˆé»˜è®¤ 70ï¼Œé˜²æ­¢å¤ªæŒ¤ï¼‰
 * @returns è®¡ç®—åçš„è¾¹è·é•¿åº¦
 */
function calculateExtractionEdgeLength(
  nodeCount: number,
  base: number = 120,
  scale: number = 0.96,
  minEdge: number = 70
): number {
  const effectiveN = Math.max(nodeCount, 3);
  const rawEdge = base * scale * Math.sqrt(3 / effectiveN);
  return Math.max(minEdge, Math.min(rawEdge, base));
}
```

**è¾¹è·è®¡ç®—ç¤ºä¾‹**ï¼š

| èŠ‚ç‚¹æ•° | è®¡ç®—è¾¹è· | è¯´æ˜ |
|-------|---------|------|
| 1-3 | 120px | ä½¿ç”¨é»˜è®¤è¾¹è· |
| 4 | ~100px | å¼€å§‹å‹ç¼© |
| 6 | ~85px | ä¸­ç­‰å‹ç¼© |
| 9+ | 70px | æœ€å°è¾¹è· |

**å¸ƒå±€ç¤ºæ„å›¾**ï¼š

```
æº¶è§£ç±»æ®µ1:  [Node1] â”€â”€120pxâ”€â”€ [Node2]
           â†‘ startY = 80 + offset

æº¶è§£ç±»æ®µ2:  [Node3] â”€â”€120pxâ”€â”€ [Node4] â”€â”€120pxâ”€â”€ [Node5]
           â†‘ startY = 80 + offset (ä¸æ®µ1å¯¹é½)

èƒå–ç±»æ®µ1:  [Node6] â”€â”€85pxâ”€â”€ [Node7] â”€â”€85pxâ”€â”€ [Node8] â”€â”€85pxâ”€â”€ [Node9]
           â†‘ startY = 80 (æ›´å¤šèŠ‚ç‚¹ï¼Œæ›´å°é—´è·)
```

#### 2.2 æ±‡èšç‚¹Yåæ ‡è®¡ç®—

**ç­–ç•¥**ï¼šæ”¯æŒä¸‰ç§ç­–ç•¥ï¼Œé»˜è®¤é‡‡ç”¨ `max` ç­–ç•¥ï¼Œå–æ‰€æœ‰å¹¶è¡Œæ®µç»ˆç‚¹çš„æœ€å¤§Yåæ ‡ã€‚

```typescript
export function calculateConvergenceY(
  parallelSegments: ProcessSegment[],
  nodeYPositions: Record<string, number>,
  nodeHeights: Record<string, number>,
  targetEdgeLength: number,
  strategy: ConvergenceStrategy = 'max'
): number {
  if (parallelSegments.length === 0) {
    return 80; // é»˜è®¤å€¼
  }

  // è®¡ç®—æ¯ä¸ªå¹¶è¡Œæ®µçš„ç»ˆç‚¹Yåæ ‡ï¼ˆæ®µæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åº•éƒ¨ + è¿çº¿é•¿åº¦ï¼‰
  const endYs = parallelSegments.map(seg => {
    const lastNode = seg.nodes[seg.nodes.length - 1];
    const lastNodeY = nodeYPositions[lastNode.id];
    const lastNodeHeight = nodeHeights[lastNode.id] || 120;
    
    // ç»ˆç‚¹Y = èŠ‚ç‚¹ä¸­å¿ƒY + èŠ‚ç‚¹é«˜åº¦çš„ä¸€åŠ + è¿çº¿é•¿åº¦
    return lastNodeY + lastNodeHeight / 2 + targetEdgeLength;
  });

  switch (strategy) {
    case 'max':
      return Math.max(...endYs);  // æ¨èï¼šæ‰€æœ‰å…¥è¾¹éƒ½å‘ä¸‹

    case 'weighted': {
      // æ ¹æ®å·¥è‰ºæ®µé•¿åº¦åŠ æƒ
      const totalSteps = parallelSegments.reduce((sum, seg) => sum + seg.nodes.length, 0);
      if (totalSteps === 0) return Math.max(...endYs);

      let weightedSum = 0;
      parallelSegments.forEach((seg, idx) => {
        const weight = seg.nodes.length / totalSteps;
        weightedSum += endYs[idx] * weight;
      });

      return weightedSum;
    }

    case 'median': {
      // å–ä¸­ä½æ•°
      const sorted = [...endYs].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
    }

    default:
      return Math.max(...endYs);
  }
}
```

**ç­–ç•¥è¯´æ˜**ï¼š

- **`max`**ï¼ˆæ¨èï¼‰ï¼šæ‰€æœ‰å…¥è¾¹éƒ½å‘ä¸‹ï¼Œç¬¦åˆè§†è§‰ä¹ æƒ¯ï¼Œç¡®ä¿æ‰€æœ‰è¿çº¿éƒ½ä»ä¸Šæ–¹æ±‡å…¥
- **`weighted`**ï¼šæ ¹æ®å·¥è‰ºæ®µé•¿åº¦åŠ æƒï¼Œé•¿æ®µæƒé‡æ›´å¤§ï¼Œé€‚åˆéœ€è¦å¹³è¡¡è§†è§‰é‡é‡çš„åœºæ™¯
- **`median`**ï¼šå–æ‰€æœ‰åˆ†æ”¯ç»ˆç‚¹çš„ä¸­ä½æ•°ï¼Œé€‚åˆéœ€è¦å‡å°‘æç«¯å€¼å½±å“çš„åœºæ™¯

#### 2.3 ä¸²è¡Œæ®µå¸ƒå±€

**ç›®æ ‡**ï¼šä»æ±‡èšç‚¹å¼€å§‹ï¼Œå‚ç›´å‘ä¸‹æ’åˆ—ï¼Œæ‰€æœ‰è¿çº¿é•¿åº¦ç»Ÿä¸€ã€‚

```typescript
export function layoutSerialSegments(
  segments: ProcessSegment[],
  startY: number,  // æ±‡èšç‚¹ä¹‹åçš„èµ·å§‹Y
  nodeHeights: Record<string, number>,
  config: SerialLayoutConfig
): Record<string, number> {
  const nodeYPositions: Record<string, number> = {};
  let currentY = startY;
  
  segments.forEach(segment => {
    segment.nodes.forEach((node, idx) => {
      nodeYPositions[node.id] = currentY;
      
      if (idx < segment.nodes.length - 1) {
        const nextNode = segment.nodes[idx + 1];
        const spacing =
          nodeHeights[node.id] / 2 +
          config.targetEdgeLength +
          nodeHeights[nextNode.id] / 2;
        
        currentY += spacing;
      }
    });
  });
  
  return nodeYPositions;
}
```

---

## èŠ‚ç‚¹å°ºå¯¸è®¡ç®—

### 1. å®½åº¦è®¡ç®—ï¼ˆåˆ†æ¡£ç­–ç•¥ï¼‰âœ… å·²å®ç°

**å®ç°ä½ç½®**ï¼š`src/components/graph/CustomNode.tsx`

æ ¹æ®è¾“å…¥æ•°é‡åˆ†æ¡£ï¼Œåœ¨èŠ‚ç‚¹æ¸²æŸ“æ—¶åŠ¨æ€è®¡ç®—ï¼š

```typescript
/**
 * æ ¹æ®è¾“å…¥æ•°é‡è®¡ç®—åˆ†æ¡£å®½åº¦
 */
const getTieredWidth = (inputCount: number): number => {
  if (inputCount <= 2) return 200;  // 1-2ä¸ªè¾“å…¥ï¼š200px
  if (inputCount <= 4) return 280;  // 3-4ä¸ªè¾“å…¥ï¼š280px
  return 360;                        // 5ä¸ªåŠä»¥ä¸Šï¼š360px
};
```

**ä½¿ç”¨æ–¹å¼**ï¼šåœ¨ `CustomNode` ç»„ä»¶ä¸­ï¼Œæ ¹æ®èŠ‚ç‚¹çš„è¾“å…¥è¾¹æ•°é‡è®¡ç®—å®½åº¦ï¼š

```typescript
const inputCount = edges.filter(e => e.target === id).length;
const nodeWidth = getTieredWidth(inputCount);

// åº”ç”¨åˆ°èŠ‚ç‚¹æ ·å¼
<div style={{ minWidth: `${nodeWidth}px`, width: `${nodeWidth}px` }}>
  {/* èŠ‚ç‚¹å†…å®¹ */}
</div>
```

### 2. é«˜åº¦è®¡ç®— âš ï¸ å®é™…å®ç°æ–¹å¼

**å®é™…å®ç°**ï¼šä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡çš„çœŸå®å°ºå¯¸ï¼Œè€Œé Canvas APIã€‚

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

```typescript
// React Flow 11 ä¸­èŠ‚ç‚¹å°ºå¯¸å­˜å‚¨åœ¨ node.width å’Œ node.height
// ç­‰å¾… React Flow è‡ªåŠ¨æµ‹é‡èŠ‚ç‚¹å°ºå¯¸
const nodes = getNodes() as FlowNode[];

// æ”¶é›†çœŸå®å°ºå¯¸ï¼ˆReact Flow æµ‹é‡çš„ï¼‰
const nodeHeights: Record<string, number> = {};
const nodeWidths: Record<string, number> = {};
nodes.forEach(node => {
  // æœªæµ‹é‡æ—¶ä½¿ç”¨é»˜è®¤å€¼
  nodeHeights[node.id] = node.height || 120;
  nodeWidths[node.id] = node.width || 200;
});
```

**ä¼˜åŠ¿**ï¼š
- âœ… ä½¿ç”¨å®é™…æ¸²æŸ“å°ºå¯¸ï¼Œæ— éœ€ä¼°ç®—
- âœ… è‡ªåŠ¨é€‚åº”å†…å®¹å˜åŒ–
- âœ… æ”¯æŒåŠ¨æ€å†…å®¹ï¼ˆå±•å¼€/æŠ˜å ï¼‰

---

### 3. æ°´å¹³å¸ƒå±€ä¼˜åŒ–

#### 4.1 åŸºäº displayOrder çš„æ°´å¹³å¯¹é½ âœ… å·²å®ç°

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

Xåæ ‡ç›´æ¥ç”± `displayOrder`ï¼ˆè¡¨æ ¼é¡ºåºï¼‰å†³å®šï¼š

```typescript
// æ¯ä¸ª Process åˆ†é…ä¸€ä¸ªæ°´å¹³"è½¦é“"
const PROCESS_LANE_WIDTH = 300; // æ¯ä¸ªå·¥è‰ºæ®µçš„æ°´å¹³è½¦é“å®½åº¦
const LANE_GAP = 64;            // è½¦é“ä¹‹é—´çš„é—´éš™
const START_X = 150;            // èµ·å§‹ X åç§»

// æ ¹æ® displayOrder åˆ†ç»„èŠ‚ç‚¹
const nodesByDisplayOrder: Record<number, FlowNode[]> = {};
nodes.forEach(node => {
  const displayOrder = node.data.displayOrder || 1;
  if (!nodesByDisplayOrder[displayOrder]) {
    nodesByDisplayOrder[displayOrder] = [];
  }
  nodesByDisplayOrder[displayOrder].push(node);
});

// ä¸ºæ¯ä¸ª displayOrder ç»„åˆ†é… X åæ ‡ï¼ˆå­˜å‚¨ä¸ºä¸­å¿ƒç‚¹ï¼‰
const displayOrders = Object.keys(nodesByDisplayOrder).map(Number).sort((a, b) => a - b);
displayOrders.forEach((displayOrder, laneIndex) => {
  const laneX = START_X + laneIndex * (PROCESS_LANE_WIDTH + LANE_GAP);
  nodesByDisplayOrder[displayOrder].forEach(node => {
    const width = nodeWidths[node.id] || 200;
    // å­˜å‚¨èŠ‚ç‚¹ä¸­å¿ƒç‚¹ï¼šè½¦é“å·¦è¾¹ç¼˜ + èŠ‚ç‚¹å®½åº¦çš„ä¸€åŠ
    nodePositions[node.id] = { x: laneX + width / 2, y: 0 };
  });
});
```

#### 4.2 æ±‡èšç‚¹æ°´å¹³å±…ä¸­ âœ… å·²å®ç°

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

é‡‡ç”¨**åŠ æƒè´¨å¿ƒç®—æ³•**ï¼ŒåŸºäºå­æ ‘è§„æ¨¡çš„**å¹³æ–¹æ ¹**åŠ æƒï¼ˆå¼±åŒ–é•¿åˆ†æ”¯çš„å½±å“ï¼Œé¿å…æ±‡èšç‚¹è¿‡åº¦åå‘ï¼‰ï¼š

```typescript
// è®¡ç®—æ±‡èšç‚¹ X åæ ‡ (åŠ æƒè´¨å¿ƒæ³•)
if (parallelSegments.length > 0) {
  let totalWeight = 0;
  let weightedXSum = 0;

  parallelSegments.forEach(segment => {
    // è¿‡æ»¤å‡ºå·²åˆ†é…ä½ç½®çš„èŠ‚ç‚¹
    const validNodes = segment.nodes.filter(n => nodePositions[n.id]);
    if (validNodes.length === 0) return;

    // è®¡ç®—è¯¥åˆ†æ”¯çš„è´¨å¿ƒ X
    const segmentCentroidX = validNodes.reduce((sum, n) => 
      sum + nodePositions[n.id].x, 0
    ) / validNodes.length;

    // æƒé‡ = èŠ‚ç‚¹æ•°é‡çš„å¹³æ–¹æ ¹ (å¼±åŒ–é•¿åˆ†æ”¯çš„å½±å“)
    const weight = Math.sqrt(validNodes.length);

    weightedXSum += segmentCentroidX * weight;
    totalWeight += weight;
  });

  if (totalWeight > 0) {
    convergenceX = weightedXSum / totalWeight;
  }
}
```

#### 4.3 å¸ƒå±€å¸é™„æœºåˆ¶ âœ… å·²å®ç°

å½“æ±‡èšç‚¹ä¸æŸå…¥è¾¹æºèŠ‚ç‚¹ X åæ ‡æ¥è¿‘æ—¶ï¼Œè‡ªåŠ¨å¸é™„å¯¹é½ï¼ŒåŒæ—¶ç¡®ä¿åœ†è§’å‡ ä½•å¯è¡Œï¼š

```typescript
// å¸ƒå±€å¸é™„å‚æ•°
const SNAP_THRESHOLD_SCREEN_PX = 24; // å±å¹•åƒç´ é˜ˆå€¼
const CORNER_RADIUS = 20;            // åœ†è§’åŠå¾„ï¼ˆä¸ SequenceEdge.tsx ä¿æŒä¸€è‡´ï¼‰
const MIN_HORIZONTAL_DISTANCE = CORNER_RADIUS * 2; // åœ†è§’å¯è¡Œæ€§çš„æœ€å°æ°´å¹³è·ç¦»

// æ”¶é›†æ‰€æœ‰è¿›å…¥æ±‡èšç‚¹çš„å¹¶è¡Œåˆ†æ”¯æœ«èŠ‚ç‚¹Xåæ ‡
const incomingXs: number[] = [];
parallelSegments.forEach(segment => {
  if (segment.nodes.length > 0) {
    const lastNode = segment.nodes[segment.nodes.length - 1];
    const lastNodeX = nodePositions[lastNode.id]?.x;
    if (lastNodeX !== undefined) {
      incomingXs.push(lastNodeX);
    }
  }
});

if (incomingXs.length > 0) {
  // è·å–å½“å‰ç¼©æ”¾çº§åˆ«ï¼Œå°†å±å¹•åƒç´ é˜ˆå€¼è½¬æ¢ä¸ºç”»å¸ƒå•ä½
  const viewport = getViewport();
  const zoom = viewport.zoom || 1;
  const snapThresholdWorld = SNAP_THRESHOLD_SCREEN_PX / zoom;

  // æ‰¾åˆ°ä¸ convergenceX æœ€è¿‘çš„å…¥è¾¹æºèŠ‚ç‚¹X
  const xNearest = incomingXs.reduce((best, x) =>
    Math.abs(x - convergenceX) < Math.abs(best - convergenceX) ? x : best
  , incomingXs[0]);

  const distanceToNearest = Math.abs(convergenceX - xNearest);
  
  if (distanceToNearest < snapThresholdWorld) {
    // åœ¨é˜ˆå€¼å†…ï¼šè€ƒè™‘å¸é™„
    if (distanceToNearest < MIN_HORIZONTAL_DISTANCE) {
      // è·ç¦»ä¸è¶³ä»¥ç”»åœ†è§’ï¼Œè°ƒæ•´åˆ°æ»¡è¶³æœ€å°è·ç¦»çš„ä½ç½®
      convergenceX = convergenceX > xNearest 
        ? xNearest + MIN_HORIZONTAL_DISTANCE 
        : xNearest - MIN_HORIZONTAL_DISTANCE;
    } else {
      // è·ç¦»è¶³å¤Ÿï¼Œå®‰å…¨å¸é™„
      convergenceX = xNearest;
    }
  } else {
    // è¶…è¿‡é˜ˆå€¼ï¼šæ£€æŸ¥æ˜¯å¦æ»¡è¶³åœ†è§’å¯è¡Œæ€§
    const problematicEdges = incomingXs.filter(x => 
      Math.abs(x - convergenceX) < MIN_HORIZONTAL_DISTANCE
    );
    
    if (problematicEdges.length > 0) {
      // è°ƒæ•´ convergenceX ä»¥æ»¡è¶³æœ€å°è·ç¦»è¦æ±‚
      const problematicX = problematicEdges.reduce((worst, x) => 
        Math.abs(x - convergenceX) < Math.abs(worst - convergenceX) ? x : worst
      , problematicEdges[0]);
      
      convergenceX = convergenceX > problematicX
        ? problematicX + MIN_HORIZONTAL_DISTANCE
        : problematicX - MIN_HORIZONTAL_DISTANCE;
    }
  }
}
```

**å¸é™„æœºåˆ¶ç¤ºæ„å›¾**ï¼š

```
å¸é™„å‰:                          å¸é™„å:
  [Node1]    [Node2]               [Node1]    [Node2]
     |          |                     |          |
     â†“          â†“                     â†“          â†“
  â”€â”€â—‹â”€â”€â”€â”€â”€â”€â”€â”€â—‹â”€â”€                   â”€â”€â”€â”€â”€â”€â—‹â”€â”€â”€â”€â”€â”€â”€
       â†“                                 â†“
  [Convergence]                    [Convergence]
  (Xåç¦»ç†æƒ³ä½ç½®)                    (Xå¸é™„åˆ°Node2çš„X)
```

**ä¸²è¡Œæ®µå¯¹é½**ï¼šä¸²è¡Œæ®µçš„èŠ‚ç‚¹ X åæ ‡ä¸æ±‡èšç‚¹å¯¹é½ï¼š

```typescript
// åº”ç”¨ X åæ ‡åˆ°ä¸²è¡Œæ®µ (ä¸æ±‡èšç‚¹å‚ç›´å¯¹é½)
if (convergenceX > 0) {
  serialSegments.forEach(segment => {
    segment.nodes.forEach(node => {
      if (nodePositions[node.id]) {
        nodePositions[node.id].x = convergenceX;
      }
    });
  });
}
```

---

### 5. å¸ƒå±€é…ç½®å‚æ•°

```typescript
const LAYOUT_CONFIG = {
  // åŸºç¡€å°ºå¯¸
  baseNodeWidth: 200,
  baseNodeHeight: 120,
  baseRankSep: 180,              // åŸºç¡€å±‚é—´è·
  extraSpacingPerInput: 30,     // æ¯ä¸ªé¢å¤–è¾“å…¥å¢åŠ çš„é—´è·
  minNodeSep: 100,               // æœ€å°èŠ‚ç‚¹é—´è·
  
  // åˆ†æ¡£å®½åº¦é…ç½®
  widthTiers: {
    tier1: { maxInputs: 2, width: 200 },
    tier2: { maxInputs: 4, width: 280 },
    tier3: { maxInputs: Infinity, width: 360 }
  },
  
  // å†…å®¹æ¢è¡Œä¼°ç®—å‚æ•°
  charWidth: 8,                  // æ¯ä¸ªå­—ç¬¦å¹³å‡å®½åº¦ï¼ˆpxï¼‰
  lineHeight: 20,                // æ¯è¡Œæ–‡æœ¬é«˜åº¦ï¼ˆpxï¼‰
  minContentWidth: 150,          // å†…å®¹åŒºåŸŸæœ€å°å®½åº¦
  
  // å·¥è‰ºæ®µå¸ƒå±€å‚æ•°
  targetEdgeLength: 120,        // ç›®æ ‡è¿çº¿é•¿åº¦ï¼ˆå›ºå®šå€¼ï¼‰
  convergenceStrategy: 'max',     // æ±‡èšç‚¹å¤„ç†ç­–ç•¥
  
  // æ°´å¹³å¸ƒå±€å‚æ•°
  PROCESS_LANE_WIDTH: 300,      // æ¯ä¸ªå·¥è‰ºæ®µçš„æ°´å¹³è½¦é“å®½åº¦
  LANE_GAP: 64,                  // è½¦é“ä¹‹é—´çš„é—´éš™
  START_X: 150,                  // èµ·å§‹ X åç§»
  
  // ä¼˜åŒ–é€‰é¡¹
  enableWeightedCentering: true, // æ˜¯å¦å¯ç”¨åŠ æƒå±…ä¸­
  centeringStrategy: 'subtree-size', // å±…ä¸­ç­–ç•¥
};
```

---

## ç²¾ç¡®é«˜åº¦è®¡ç®—

### å®é™…å®ç°æ–¹å¼ âš ï¸

**æ³¨æ„**ï¼šæ–‡æ¡£ä¸­æè¿°çš„ Canvas API ç²¾ç¡®æµ‹é‡æ–¹æ³•**æœªåœ¨ä»£ç ä¸­å®ç°**ã€‚å½“å‰å®ç°ä½¿ç”¨ React Flow çš„è‡ªåŠ¨å°ºå¯¸æµ‹é‡ã€‚

### å½“å‰å®ç°ï¼šReact Flow è‡ªåŠ¨æµ‹é‡

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

ç³»ç»Ÿä½¿ç”¨ React Flow 11 çš„è‡ªåŠ¨å°ºå¯¸æµ‹é‡åŠŸèƒ½ï¼Œåœ¨èŠ‚ç‚¹æ¸²æŸ“åè‡ªåŠ¨è·å–çœŸå®å°ºå¯¸ï¼š

```typescript
// ç­‰å¾… React Flow è‡ªåŠ¨æµ‹é‡æ‰€æœ‰èŠ‚ç‚¹çš„çœŸå®å°ºå¯¸
const nodesInitialized = useNodesInitialized();

useLayoutEffect(() => {
  // æ¡ä»¶1: èŠ‚ç‚¹å·²åˆå§‹åŒ–ï¼ˆReact Flow å·²æµ‹é‡å°ºå¯¸ï¼‰
  if (!nodesInitialized) {
    return;
  }

  const nodes = getNodes() as FlowNode[];
  
  // React Flow 11 ä¸­èŠ‚ç‚¹å°ºå¯¸å­˜å‚¨åœ¨ node.width å’Œ node.height
  const nodeHeights: Record<string, number> = {};
  const nodeWidths: Record<string, number> = {};
  nodes.forEach(node => {
    // æœªæµ‹é‡æ—¶ä½¿ç”¨é»˜è®¤å€¼
    nodeHeights[node.id] = node.height || 120;
    nodeWidths[node.id] = node.width || 200;
  });
  
  // ä½¿ç”¨çœŸå®å°ºå¯¸è¿›è¡Œå¸ƒå±€è®¡ç®—
  // ...
}, [nodesInitialized, getNodes]);
```

### ä¼˜åŠ¿

- âœ… **çœŸå®å°ºå¯¸**ï¼šä½¿ç”¨å®é™…æ¸²æŸ“å°ºå¯¸ï¼Œæ— éœ€ä¼°ç®—
- âœ… **è‡ªåŠ¨é€‚åº”**ï¼šè‡ªåŠ¨é€‚åº”å†…å®¹å˜åŒ–ï¼ˆå±•å¼€/æŠ˜å ã€åŠ¨æ€å†…å®¹ï¼‰
- âœ… **æ— éœ€ç»´æŠ¤**ï¼šä¸éœ€è¦æ‰‹åŠ¨è®¡ç®—æ–‡å­—æ¢è¡Œå’Œé«˜åº¦

---

## è°ƒè¯•æ¨¡å¼

### åŠŸèƒ½æ¦‚è¿°

è°ƒè¯•æ¨¡å¼æä¾›å¯è§†åŒ–å·¥å…·ï¼Œå®æ—¶æ˜¾ç¤ºè¿çº¿é•¿åº¦å’Œè¯¯å·®ï¼Œå¸®åŠ©å¿«é€Ÿå®šä½å¸ƒå±€é—®é¢˜ã€‚

### å¯ç”¨æ–¹å¼

**æ–¹æ³•1ï¼šUI å¼€å…³**
- ç‚¹å‡»æµç¨‹å›¾å³ä¸Šè§’çš„è°ƒè¯•æŒ‰é’®
- æŒ‰é’®çŠ¶æ€ï¼šğŸ”´ è°ƒè¯•: å¼€ / âšª è°ƒè¯•: å…³

**æ–¹æ³•2ï¼šæ§åˆ¶å°**
```javascript
localStorage.setItem('debug_layout', 'true');  // å¼€å¯
localStorage.setItem('debug_layout', 'false'); // å…³é—­
```

### æ˜¾ç¤ºå†…å®¹

#### 1. è¿çº¿é•¿åº¦æ ‡æ³¨

æ¯æ¡è¿çº¿æ—è¾¹æ˜¾ç¤ºï¼š
- **å®é™…é•¿åº¦**ï¼šä¾‹å¦‚ `120.3px`
- **è¯¯å·®æ ‡æ³¨**ï¼šè¯¯å·® > 0.5px æ—¶æ˜¾ç¤º `(Î”+0.3)`

#### 2. é¢œè‰²ç¼–ç 

æ ¹æ®è¯¯å·®å¤§å°ä½¿ç”¨ä¸åŒé¢œè‰²ï¼š

| é¢œè‰² | è¯¯å·®èŒƒå›´ | è¯´æ˜ |
|------|---------|------|
| ğŸŸ¢ **ç»¿è‰²** | < 5px | è¯¯å·®å¾ˆå°ï¼Œå¸ƒå±€è‰¯å¥½ |
| ğŸŸ¡ **é»„è‰²** | 5-10px | è¯¯å·®ä¸­ç­‰ï¼Œå¯ä¼˜åŒ– |
| ğŸ”´ **çº¢è‰²** | > 10px | è¯¯å·®è¾ƒå¤§ï¼Œéœ€è¦æ£€æŸ¥ |

#### 3. æ‚¬åœæç¤º

é¼ æ ‡æ‚¬åœåœ¨æ ‡ç­¾ä¸Šæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼š
```
ç›®æ ‡: 120px, è¯¯å·®: 0.3px
```

### å®ç°ç»†èŠ‚

**ç»„ä»¶ä½ç½®**ï¼š`src/components/graph/DebugOverlay.tsx`

**æ ¸å¿ƒé€»è¾‘**ï¼š

```typescript
// è®¡ç®—æ¯æ¡è¿çº¿çš„å®é™…é•¿åº¦
const sourceBottom = sourceCenterY + sourceHeight / 2;
const targetTop = targetCenterY - targetHeight / 2;
const actualLength = targetTop - sourceBottom;

// è®¡ç®—è¯¯å·®
const error = Math.abs(actualLength - targetEdgeLength);

// ç¡®å®šé¢œè‰²
let color: 'green' | 'yellow' | 'red' = 'green';
if (error > 10) color = 'red';
else if (error > 5) color = 'yellow';
```

**åæ ‡è®¡ç®—**ï¼š
- ä½¿ç”¨èŠ‚ç‚¹ä¸­å¿ƒåæ ‡ï¼ˆè€Œéå·¦ä¸Šè§’ï¼‰
- è€ƒè™‘è§†å£å˜æ¢ï¼ˆzoom, panï¼‰
- æ ‡ç­¾ä½ç½®åœ¨è¿çº¿ä¸­ç‚¹

### ä½¿ç”¨åœºæ™¯

1. **å¸ƒå±€éªŒè¯**ï¼šæ£€æŸ¥è¿çº¿é•¿åº¦æ˜¯å¦ç»Ÿä¸€
2. **é—®é¢˜å®šä½**ï¼šå¿«é€Ÿæ‰¾åˆ°è¯¯å·®è¾ƒå¤§çš„è¿çº¿
3. **ç®—æ³•è°ƒä¼˜**ï¼šæ ¹æ®è¯¯å·®æ•°æ®è°ƒæ•´å¸ƒå±€å‚æ•°
4. **æ€§èƒ½åˆ†æ**ï¼šç»Ÿè®¡æ•´ä½“è¯¯å·®åˆ†å¸ƒ

### æ•°æ®ç»Ÿè®¡

æ§åˆ¶å°è¾“å‡ºå¸ƒå±€éªŒè¯ç»Ÿè®¡ï¼š

```javascript
[Layout] å¸ƒå±€éªŒè¯: {
  parallelSegments: [
    {
      segmentId: "parallel-segment-0",
      avgEdgeLength: "120.2",
      stdDeviation: "1.5",  // æ ‡å‡†å·®
      minEdgeLength: "118.5",
      maxEdgeLength: "122.1"
    }
  ],
  overall: {
    avgParallelEdgeLength: "120.1",
    avgSerialEdgeLength: "119.8"
  }
}
```

**ç›®æ ‡æŒ‡æ ‡**ï¼š
- æ ‡å‡†å·® < 3pxï¼ˆå½“å‰çº¦ 8-12pxï¼Œæ”¹è¿›åé¢„æœŸ < 3pxï¼‰
- å¹³å‡è¯¯å·® < 2px

### å®ç°ç»†èŠ‚

**ç»„ä»¶ä½ç½®**ï¼š`src/components/graph/DebugOverlay.tsx`

**æ ¸å¿ƒé€»è¾‘**ï¼š

```typescript
// è®¡ç®—æ¯æ¡è¿çº¿çš„å®é™…é•¿åº¦
const sourceBottom = sourceCenterY + sourceHeight / 2;
const targetTop = targetCenterY - targetHeight / 2;
const actualLength = targetTop - sourceBottom;

// è®¡ç®—è¯¯å·®
const error = Math.abs(actualLength - targetEdgeLength);

// ç¡®å®šé¢œè‰²
let color: 'green' | 'yellow' | 'red' = 'green';
if (error > 10) color = 'red';
else if (error > 5) color = 'yellow';
```

**èŠ‚ç‚¹è°ƒè¯•ä¿¡æ¯**ï¼š

è°ƒè¯•æ¨¡å¼è¿˜ä¼šæ˜¾ç¤ºæ¯ä¸ªèŠ‚ç‚¹çš„å°ºå¯¸å’Œä½ç½®ä¿¡æ¯ï¼š

```typescript
const nodeDebugInfos = nodes.map(node => {
  const height = node.height!;
  const width = node.width!;
  const centerX = node.position.x + width / 2;
  const centerY = node.position.y + height / 2;
  
  return {
    id: node.id,
    x: node.position.x + width, // å³ä¸Šè§’
    y: node.position.y,
    width,
    height,
    centerX,
    centerY,
    topY: node.position.y,
    bottomY: node.position.y + height,
  };
});
```

**åæ ‡è®¡ç®—**ï¼š
- ä½¿ç”¨èŠ‚ç‚¹ä¸­å¿ƒåæ ‡ï¼ˆè€Œéå·¦ä¸Šè§’ï¼‰è¿›è¡Œè®¡ç®—
- è€ƒè™‘è§†å£å˜æ¢ï¼ˆzoom, panï¼‰
- æ ‡ç­¾ä½ç½®åœ¨è¿çº¿ä¸­ç‚¹

### ç»Ÿè®¡é¢æ¿

**ç»„ä»¶ä½ç½®**ï¼š`src/components/graph/DebugStatsPanel.tsx`

ç»Ÿè®¡é¢æ¿æ˜¾ç¤ºå¸ƒå±€éªŒè¯çš„ç»Ÿè®¡ä¿¡æ¯ï¼š

- **å¹¶è¡Œå·¥è‰ºæ®µç»Ÿè®¡**ï¼šæ¯ä¸ªå¹¶è¡Œæ®µçš„èŠ‚ç‚¹æ•°ã€è¾¹æ•°ã€å¹³å‡é•¿åº¦ã€æ ‡å‡†å·®ã€æœ€å°/æœ€å¤§é•¿åº¦
- **ä¸²è¡Œå·¥è‰ºæ®µç»Ÿè®¡**ï¼šä¸²è¡Œæ®µçš„è¾¹æ•°ã€å¹³å‡é•¿åº¦ã€æ ‡å‡†å·®ã€æœ€å°/æœ€å¤§é•¿åº¦
- **æ€»ä½“ç»Ÿè®¡**ï¼šå¹¶è¡Œè¾¹æ€»æ•°ã€ä¸²è¡Œè¾¹æ€»æ•°ã€å¹¶è¡Œå¹³å‡é•¿åº¦ã€ä¸²è¡Œå¹³å‡é•¿åº¦

**å®ç°é€»è¾‘**ï¼š

```typescript
const layoutValidation = validateSegmentLayout(
  parallelSegments,
  serialSegments,
  nodePositions,
  nodeHeights,
  120 // TARGET_EDGE_LENGTH
);
```

---

## èµ°å»Šè·¯ç”±æœºåˆ¶

### æ¦‚è¿°

å½“å¤šæ¡è¿çº¿æ±‡å…¥åŒä¸€èŠ‚ç‚¹æ—¶ï¼Œä½¿ç”¨èµ°å»Šè·¯ç”±ï¼ˆCorridor Routingï¼‰é¿å…è¿çº¿äº¤å‰ï¼Œæé«˜å¯è¯»æ€§ã€‚

### å®ç°ä½ç½®

**ç»„ä»¶ä½ç½®**ï¼š`src/components/graph/SequenceEdge.tsx`

### è·¯ç”±åˆ¤æ–­

```typescript
// åˆ¤æ–­æ˜¯å¦ä½¿ç”¨èµ°å»Šè·¯ç”±
const incomingTotal = data?.incomingTotal;
const useCorridor = incomingTotal !== undefined && incomingTotal > 1;
```

å½“ç›®æ ‡èŠ‚ç‚¹çš„å…¥è¾¹æ€»æ•° > 1 æ—¶ï¼Œå¯ç”¨èµ°å»Šè·¯ç”±ã€‚

### è·¯å¾„ç”Ÿæˆ

èµ°å»Šè·¯ç”±é‡‡ç”¨ä¸‰æ®µå¼è·¯å¾„ï¼š**å‚ç›´ä¸‹é™ â†’ æ°´å¹³ç§»åŠ¨ â†’ å‚ç›´ä¸Šå‡**ï¼Œå¹¶å¸¦æœ‰åœ†è§’è¿‡æ¸¡ã€‚

```typescript
function generateCorridorPath(
  sourceX: number,
  sourceY: number,
  targetX: number,
  targetY: number
): string {
  // èµ°å»Šå‚æ•°
  const CORRIDOR_CLEARANCE_PX = 60; // èµ°å»Šè·ç¦»ç›®æ ‡èŠ‚ç‚¹çš„å‡€ç©º
  const MIN_TARGET_CLEARANCE_PX = 24; // æœ€å°ç›®æ ‡èŠ‚ç‚¹å‡€ç©º
  const MIN_SOURCE_DROP_PX = 12; // æœ€å°æºèŠ‚ç‚¹ä¸‹é™è·ç¦»
  const CORNER_RADIUS = 20; // æ‹è§’åœ†è§’åŠå¾„

  // è®¡ç®—èµ°å»ŠYåæ ‡
  let corridorY = targetY - CORRIDOR_CLEARANCE_PX;
  
  // å¤¹ç´§æ¡ä»¶1ï¼šç¡®ä¿èµ°å»Šä¸å‹ä½ç›®æ ‡èŠ‚ç‚¹
  const minCorridorY = targetY - MIN_TARGET_CLEARANCE_PX;
  corridorY = Math.min(corridorY, minCorridorY);
  
  // å¤¹ç´§æ¡ä»¶2ï¼šç¡®ä¿æœ‰è¶³å¤Ÿçš„ä¸‹é™è·ç¦»
  const minSourceY = sourceY + MIN_SOURCE_DROP_PX;
  corridorY = Math.max(corridorY, minSourceY);
  
  // å¦‚æœæºç‚¹å·²ç»åœ¨ç›®æ ‡ç‚¹ä¸‹æ–¹ï¼Œä½¿ç”¨ç®€å•çš„å‚ç›´è·¯å¾„
  if (sourceY >= targetY) {
    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;
  }
  
  // è®¡ç®—æ°´å¹³ç§»åŠ¨æ–¹å‘
  const horizontalDistance = Math.abs(targetX - sourceX);
  
  // å¦‚æœæ°´å¹³è·ç¦»å¾ˆå°ï¼Œä½¿ç”¨ç®€å•çš„å‚ç›´è·¯å¾„
  if (horizontalDistance < CORNER_RADIUS * 2) {
    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;
  }
  
  // ç”Ÿæˆä¸‰æ®µå¼è·¯å¾„ï¼ˆå¸¦åœ†è§’ï¼‰
  // 1. ä»æºç‚¹å‚ç›´ä¸‹é™åˆ°èµ°å»Šï¼ˆç•™å‡ºåœ†è§’ç©ºé—´ï¼‰
  const verticalDropEndY = corridorY - CORNER_RADIUS;
  
  // 2. åœ†è§’è¿‡æ¸¡åˆ°æ°´å¹³æ®µ
  const isTargetRight = targetX > sourceX;
  const cornerX1 = isTargetRight 
    ? sourceX + CORNER_RADIUS 
    : sourceX - CORNER_RADIUS;
  
  // 3. æ°´å¹³ç§»åŠ¨åˆ°ç›®æ ‡Xé™„è¿‘ï¼ˆç•™å‡ºåœ†è§’ç©ºé—´ï¼‰
  const cornerX2 = isTargetRight 
    ? targetX - CORNER_RADIUS 
    : targetX + CORNER_RADIUS;
  
  // 4. åœ†è§’è¿‡æ¸¡åˆ°å‚ç›´æ®µ
  const verticalRiseStartY = corridorY + CORNER_RADIUS;
  
  // æ„å»ºå®Œæ•´è·¯å¾„
  const path = [
    `M ${sourceX} ${sourceY}`,                    // èµ·ç‚¹
    `L ${sourceX} ${verticalDropEndY}`,           // å‚ç›´ä¸‹é™
    `Q ${sourceX} ${corridorY} ${cornerX1} ${corridorY}`, // åœ†è§’1
    `L ${cornerX2} ${corridorY}`,                 // æ°´å¹³ç§»åŠ¨
    `Q ${targetX} ${corridorY} ${targetX} ${verticalRiseStartY}`, // åœ†è§’2
    `L ${targetX} ${targetY}`,                    // å‚ç›´ä¸Šå‡
  ].join(' ');
  
  return path;
}
```

### è·¯å¾„ç¤ºæ„å›¾

```
æºèŠ‚ç‚¹ (sourceX, sourceY)
    |
    | å‚ç›´ä¸‹é™
    |
    â””â”€â” åœ†è§’1
      |
      | æ°´å¹³ç§»åŠ¨ï¼ˆèµ°å»Šï¼‰
      |
    â”Œâ”€â”˜ åœ†è§’2
    |
    | å‚ç›´ä¸Šå‡
    |
ç›®æ ‡èŠ‚ç‚¹ (targetX, targetY)
```

### ä¼˜åŠ¿

- âœ… **é¿å…äº¤å‰**ï¼šå¤šæ¡è¿çº¿é€šè¿‡èµ°å»Šæ°´å¹³å¯¹é½ï¼Œé¿å…äº¤å‰
- âœ… **è§†è§‰æ¸…æ™°**ï¼šæ‰€æœ‰æ±‡å…¥è¿çº¿åœ¨åŒä¸€æ°´å¹³çº¿ä¸Šï¼Œæ˜“äºè¯†åˆ«
- âœ… **å¹³æ»‘è¿‡æ¸¡**ï¼šä½¿ç”¨åœ†è§’è¿‡æ¸¡ï¼Œè§†è§‰æ•ˆæœæ›´å¥½

---

## é‡æ’è¿­ä»£æœºåˆ¶

### æ¦‚è¿°

é¦–æ¬¡å¸ƒå±€åï¼ŒèŠ‚ç‚¹å°ºå¯¸å¯èƒ½å‘ç”Ÿå˜åŒ–ï¼ˆReact Flow é‡æ–°æµ‹é‡ï¼‰ï¼Œå¯¼è‡´è¿çº¿é•¿åº¦ä¸å‡†ç¡®ã€‚é‡æ’è¿­ä»£æœºåˆ¶è‡ªåŠ¨æ ¡éªŒé—´è·ï¼Œå¿…è¦æ—¶é‡æ–°å¸ƒå±€ã€‚

### å®ç°ä½ç½®

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

### è¿­ä»£æµç¨‹

```mermaid
flowchart TD
    A[é¦–æ¬¡å¸ƒå±€å®Œæˆ] --> B[ç­‰å¾…1-2å¸§]
    B --> C[é‡æ–°è·å–èŠ‚ç‚¹å°ºå¯¸]
    C --> D[æ ¡éªŒæ‰€æœ‰è¿çº¿é•¿åº¦]
    D --> E{è¯¯å·® > 5px?}
    E -->|æ˜¯| F{è¿­ä»£æ¬¡æ•° < 3?}
    E -->|å¦| G[å¸ƒå±€å®Œæˆ]
    F -->|æ˜¯| H[é‡ç½®å¸ƒå±€æ ‡è®°]
    F -->|å¦| I[è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°]
    H --> J[è§¦å‘é‡æ’]
    J --> A
    I --> G
```

### å®ç°ä»£ç 

```typescript
const TARGET_EDGE_LENGTH = 120;
const TOLERANCE = 5; // å…è®¸è¯¯å·® 5px
const MAX_ITERATIONS = 3; // æœ€å¤šé‡æ’ 3 æ¬¡

// ç­‰å¾… 1-2 å¸§è®© ReactFlow å®Œæˆé‡æ–°æµ‹é‡
window.requestAnimationFrame(() => {
  window.requestAnimationFrame(() => {
    // é‡æ–°è·å–èŠ‚ç‚¹ï¼ˆå¯èƒ½å·²é‡æ–°æµ‹é‡å°ºå¯¸ï¼‰
    const currentNodes = getNodes() as FlowNode[];
    const currentEdges = getEdges() as RecipeEdge[];

    // æ ¡éªŒè¾¹é—´è·
    let maxError = 0;
    let invalidEdgeCount = 0;

    currentEdges.forEach(edge => {
      const sourceNode = currentNodes.find(n => n.id === edge.source);
      const targetNode = currentNodes.find(n => n.id === edge.target);

      if (!sourceNode || !targetNode) {
        return;
      }

      // ä½¿ç”¨é»˜è®¤å°ºå¯¸ï¼Œä¸å¸ƒå±€è®¡ç®—é˜¶æ®µä¿æŒä¸€è‡´
      const sourceHeight = sourceNode.height || 120;

      // è®¡ç®—å®é™…é—´è·
      const sourceBottom = sourceNode.position.y + sourceHeight;
      const targetTop = targetNode.position.y;
      const actualGap = targetTop - sourceBottom;
      const error = Math.abs(actualGap - TARGET_EDGE_LENGTH);

      if (error > TOLERANCE) {
        invalidEdgeCount++;
        maxError = Math.max(maxError, error);
      }
    });

    console.log('[LayoutController] é—´è·æ ¡éªŒ:', {
      iteration: layoutIterationRef.current,
      totalEdges: currentEdges.length,
      invalidEdges: invalidEdgeCount,
      maxError: maxError.toFixed(1),
      tolerance: TOLERANCE,
    });

    // åˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ’
    const needsRelayout = invalidEdgeCount > 0 && layoutIterationRef.current < MAX_ITERATIONS;

    if (needsRelayout) {
      console.log(`[LayoutController] é—´è·ä¸åˆæ ¼ï¼Œè§¦å‘ç¬¬ ${layoutIterationRef.current + 1} æ¬¡é‡æ’`);
      layoutIterationRef.current++;
      // é‡ç½®å¸ƒå±€æ ‡è®°ï¼Œé€šè¿‡ state è§¦å‘ä¸‹ä¸€è½®å¸ƒå±€
      hasLayoutedRef.current = false;
      setRelayoutTrigger(prev => prev + 1); // è§¦å‘é‡æ’
      return;
    }

    // é—´è·åˆæ ¼æˆ–è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œå®Œæˆå¸ƒå±€
    if (layoutIterationRef.current >= MAX_ITERATIONS && invalidEdgeCount > 0) {
      console.warn('[LayoutController] è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œåœæ­¢é‡æ’ï¼ˆéƒ¨åˆ†è¾¹é—´è·å¯èƒ½ä»ä¸åˆæ ¼ï¼‰');
    } else {
      console.log('[LayoutController] é—´è·æ ¡éªŒé€šè¿‡ï¼Œå¸ƒå±€å®Œæˆ');
    }

    // æ ‡è®°å·²å¸ƒå±€
    hasLayoutedRef.current = true;
    layoutIterationRef.current = 0; // é‡ç½®è¿­ä»£æ¬¡æ•°

    // æ‰§è¡Œ fitView
    fitView({ padding: 0.2, duration: 0 });
    onLayoutComplete();
  });
});
```

### è¿­ä»£å‚æ•°

| å‚æ•° | å€¼ | è¯´æ˜ |
|------|-----|------|
| `TARGET_EDGE_LENGTH` | 120px | ç›®æ ‡è¿çº¿é•¿åº¦ |
| `TOLERANCE` | 5px | å…è®¸è¯¯å·®èŒƒå›´ |
| `MAX_ITERATIONS` | 3 | æœ€å¤§è¿­ä»£æ¬¡æ•° |

### ä¼˜åŠ¿

- âœ… **è‡ªåŠ¨ä¿®æ­£**ï¼šè‡ªåŠ¨æ£€æµ‹å¹¶ä¿®æ­£å¸ƒå±€è¯¯å·®
- âœ… **é˜²æ­¢æ— é™å¾ªç¯**ï¼šæœ€å¤šè¿­ä»£3æ¬¡ï¼Œé¿å…æ— é™é‡æ’
- âœ… **å®¹é”™æœºåˆ¶**ï¼šå³ä½¿è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œä¹Ÿä¼šå®Œæˆå¸ƒå±€

---

## èŠ‚ç‚¹å°ºå¯¸å¤„ç†

### æ¦‚è¿°

èŠ‚ç‚¹å°ºå¯¸å¤„ç†æ˜¯å¸ƒå±€ç®—æ³•çš„å…³é”®ç¯èŠ‚ã€‚ç³»ç»Ÿä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡çš„çœŸå®å°ºå¯¸ï¼Œè€Œéä¼°ç®—å€¼ã€‚

### React Flow è‡ªåŠ¨æµ‹é‡

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

React Flow 11 åœ¨èŠ‚ç‚¹æ¸²æŸ“åè‡ªåŠ¨æµ‹é‡èŠ‚ç‚¹å°ºå¯¸ï¼Œå­˜å‚¨åœ¨ `node.width` å’Œ `node.height` ä¸­ã€‚

```typescript
// ç­‰å¾… React Flow è‡ªåŠ¨æµ‹é‡æ‰€æœ‰èŠ‚ç‚¹çš„çœŸå®å°ºå¯¸
const nodesInitialized = useNodesInitialized();

useLayoutEffect(() => {
  // æ¡ä»¶1: èŠ‚ç‚¹å·²åˆå§‹åŒ–ï¼ˆReact Flow å·²æµ‹é‡å°ºå¯¸ï¼‰
  if (!nodesInitialized) {
    return;
  }

  const nodes = getNodes() as FlowNode[];
  
  // React Flow 11 ä¸­èŠ‚ç‚¹å°ºå¯¸å­˜å‚¨åœ¨ node.width å’Œ node.height
  const nodeHeights: Record<string, number> = {};
  const nodeWidths: Record<string, number> = {};
  nodes.forEach(node => {
    // æœªæµ‹é‡æ—¶ä½¿ç”¨é»˜è®¤å€¼
    nodeHeights[node.id] = node.height || 120;
    nodeWidths[node.id] = node.width || 200;
  });
  
  // ä½¿ç”¨çœŸå®å°ºå¯¸è¿›è¡Œå¸ƒå±€è®¡ç®—
  // ...
}, [nodesInitialized, getNodes]);
```

### é»˜è®¤å€¼å¤„ç†

å½“èŠ‚ç‚¹å°ºå¯¸æœªæµ‹é‡æ—¶ï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼š

```typescript
// æ£€æŸ¥èŠ‚ç‚¹å°ºå¯¸ï¼ˆæ”¾å®½æ¡ä»¶ï¼šå…è®¸éƒ¨åˆ†èŠ‚ç‚¹æœªæµ‹é‡ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸ç»§ç»­å¸ƒå±€ï¼‰
const measuredNodes = nodes.filter(n => n.width && n.height);
const unmeasuredNodes = nodes.filter(n => !n.width || !n.height);

if (unmeasuredNodes.length > 0) {
  console.warn('[LayoutController] éƒ¨åˆ†èŠ‚ç‚¹å°ºå¯¸æœªæµ‹é‡ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸:',
    unmeasuredNodes.map(n => n.id)
  );
}

// ä½¿ç”¨é»˜è®¤å€¼
nodes.forEach(node => {
  nodeHeights[node.id] = node.height || 120;  // é»˜è®¤é«˜åº¦ 120px
  nodeWidths[node.id] = node.width || 200;     // é»˜è®¤å®½åº¦ 200px
});
```

### æµ‹é‡é‡è¯•æœºåˆ¶ âœ… å·²å®ç°

å½“æ‰€æœ‰èŠ‚ç‚¹å°ºå¯¸éƒ½æœªæµ‹é‡æ—¶ï¼ˆå¯èƒ½æ˜¯ React Flow ä¸´æ—¶æ¸…ç©ºï¼‰ï¼Œç³»ç»Ÿä¼šå»¶è¿Ÿé‡è¯•è€Œä¸æ˜¯ä½¿ç”¨é»˜è®¤å°ºå¯¸ï¼š

```typescript
const MAX_MEASUREMENT_RETRIES = 5; // æœ€å¤šé‡è¯• 5 æ¬¡

// å¦‚æœæ‰€æœ‰èŠ‚ç‚¹éƒ½æœªæµ‹é‡ï¼Œå»¶è¿Ÿé‡è¯•
if (measuredNodes.length === 0 && nodes.length > 0) {
  if (measurementRetryRef.current < MAX_MEASUREMENT_RETRIES) {
    console.warn(`[LayoutController] æ‰€æœ‰èŠ‚ç‚¹å°ºå¯¸æœªæµ‹é‡ï¼Œå»¶è¿Ÿé‡è¯• (${measurementRetryRef.current + 1}/${MAX_MEASUREMENT_RETRIES})`);
    measurementRetryRef.current++;
    
    // å»¶è¿Ÿ 2-3 å¸§åé‡è¯•
    measurementRetryTimeoutRef.current = window.requestAnimationFrame(() => {
      window.requestAnimationFrame(() => {
        measurementRetryTimeoutRef.current = null;
        // é€šè¿‡é€’å¢ relayoutTrigger è§¦å‘é‡è¯•
        setRelayoutTrigger(prev => prev + 1);
      });
    });
    return; // ä¸ç»§ç»­å¸ƒå±€ï¼Œç­‰å¾…é‡è¯•
  } else {
    console.warn('[LayoutController] è¾¾åˆ°æœ€å¤§æµ‹é‡é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸ç»§ç»­å¸ƒå±€');
    measurementRetryRef.current = 0;
  }
}
```

**é‡è¯•æœºåˆ¶æµç¨‹**ï¼š

```mermaid
flowchart TD
    A[å¼€å§‹å¸ƒå±€] --> B{æ‰€æœ‰èŠ‚ç‚¹å·²æµ‹é‡?}
    B -->|æ˜¯| C[ç»§ç»­å¸ƒå±€è®¡ç®—]
    B -->|å¦| D{é‡è¯•æ¬¡æ•° < 5?}
    D -->|æ˜¯| E[ç­‰å¾… 2-3 å¸§]
    E --> F[é€’å¢é‡è¯•è®¡æ•°]
    F --> G[è§¦å‘é‡æ–°å¸ƒå±€]
    G --> A
    D -->|å¦| H[ä½¿ç”¨é»˜è®¤å°ºå¯¸]
    H --> C
```

**å‚æ•°è¯´æ˜**ï¼š

| å‚æ•° | å€¼ | è¯´æ˜ |
|------|-----|------|
| `MAX_MEASUREMENT_RETRIES` | 5 | æœ€å¤§é‡è¯•æ¬¡æ•° |
| é‡è¯•é—´éš” | 2-3 å¸§ | ä½¿ç”¨ `requestAnimationFrame` åµŒå¥— |

### ä¼˜åŠ¿

- âœ… **çœŸå®å°ºå¯¸**ï¼šä½¿ç”¨å®é™…æ¸²æŸ“å°ºå¯¸ï¼Œæ— éœ€ä¼°ç®—
- âœ… **è‡ªåŠ¨é€‚åº”**ï¼šè‡ªåŠ¨é€‚åº”å†…å®¹å˜åŒ–ï¼ˆå±•å¼€/æŠ˜å ã€åŠ¨æ€å†…å®¹ï¼‰
- âœ… **æ— éœ€ç»´æŠ¤**ï¼šä¸éœ€è¦æ‰‹åŠ¨è®¡ç®—æ–‡å­—æ¢è¡Œå’Œé«˜åº¦
- âœ… **å®¹é”™æœºåˆ¶**ï¼šæœªæµ‹é‡æ—¶ä½¿ç”¨é»˜è®¤å€¼ï¼Œä¿è¯å¸ƒå±€ä¸ä¸­æ–­
- âœ… **æ™ºèƒ½é‡è¯•**ï¼šé¿å…åœ¨ React Flow ä¸´æ—¶æ¸…ç©ºå°ºå¯¸æ—¶ä½¿ç”¨é”™è¯¯æ•°æ®

### ä¸ Canvas API çš„å¯¹æ¯”

**æ³¨æ„**ï¼šæ–‡æ¡£ä¸­æè¿°çš„ Canvas API ç²¾ç¡®æµ‹é‡æ–¹æ³•ï¼ˆ`measureTextHeight`, `wrapText`ï¼‰**æœªåœ¨ä»£ç ä¸­å®ç°**ã€‚å½“å‰å®ç°ä¾èµ– React Flow çš„è‡ªåŠ¨å°ºå¯¸æµ‹é‡ã€‚

**åŸå› **ï¼šReact Flow çš„è‡ªåŠ¨å°ºå¯¸æµ‹é‡å·²ç»æä¾›äº†å‡†ç¡®çš„èŠ‚ç‚¹å°ºå¯¸ï¼Œæ— éœ€æ‰‹åŠ¨è®¡ç®—ã€‚

---

## å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šå¸ƒå±€æŠ–åŠ¨

**ç—‡çŠ¶**ï¼šé¡µé¢åˆ·æ–°æˆ–å†…å®¹å˜åŒ–æ—¶ï¼ŒèŠ‚ç‚¹ä½ç½®å‘ç”Ÿè·³åŠ¨ã€‚

**åŸå› **ï¼š
- èŠ‚ç‚¹ä½ç½®ç¼“å­˜æœªæ­£ç¡®æ›´æ–°
- å¸ƒå±€ç®—æ³•åœ¨èŠ‚ç‚¹å°ºå¯¸æœªæµ‹é‡æ—¶æ‰§è¡Œ

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. ç¡®ä¿ä½¿ç”¨ `layoutTrigger` æ£€æµ‹å†…å®¹å˜åŒ–
2. ç­‰å¾…èŠ‚ç‚¹åˆå§‹åŒ–å®Œæˆåå†æ‰§è¡Œå¸ƒå±€
3. ä½¿ç”¨ `hasLayoutedRef` é˜²æ­¢é‡å¤å¸ƒå±€

```typescript
// ç­‰å¾…èŠ‚ç‚¹åˆå§‹åŒ–
if (!nodesInitialized) {
  return;
}

// æ£€æŸ¥æ˜¯å¦å·²å¸ƒå±€è¿‡
if (hasLayoutedRef.current) {
  return;
}
```

### é—®é¢˜2ï¼šä½ç½®ä¸¢å¤±

**ç—‡çŠ¶**ï¼šæŸäº›èŠ‚ç‚¹ä½ç½®ä¸º (0, 0) æˆ–æœªåˆ†é…ä½ç½®ã€‚

**åŸå› **ï¼š
- èŠ‚ç‚¹æœªæ­£ç¡®åˆ†é…åˆ°å·¥è‰ºæ®µ
- ä½ç½®è®¡ç®—é€»è¾‘é—æ¼æŸäº›èŠ‚ç‚¹

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. æ£€æŸ¥å¹¶å¤„ç†å®Œå…¨æ²¡æœ‰ä½ç½®çš„èŠ‚ç‚¹
2. ä¸ºç¼ºå¤±èŠ‚ç‚¹åˆ†é…é»˜è®¤ä½ç½®

```typescript
// æ£€æŸ¥å¹¶å¤„ç†å®Œå…¨æ²¡æœ‰ä½ç½®çš„èŠ‚ç‚¹
const nodesWithoutPosition = nodes.filter(n => !nodePositions[n.id]);
if (nodesWithoutPosition.length > 0) {
  console.warn('[LayoutController] å‘ç°æœªåˆ†é…ä½ç½®çš„èŠ‚ç‚¹:',
    nodesWithoutPosition.map(n => n.id)
  );

  // ä¸ºç¼ºå¤±èŠ‚ç‚¹åˆ†é…é»˜è®¤ä½ç½®
  nodesWithoutPosition.forEach(node => {
    const displayOrder = node.data.displayOrder || 1;
    const laneIndex = displayOrders.indexOf(displayOrder);
    const laneX = laneIndex >= 0
      ? START_X + laneIndex * (PROCESS_LANE_WIDTH + LANE_GAP)
      : START_X;
    const width = nodeWidths[node.id] || 200;
    nodePositions[node.id] = { x: laneX + width / 2, y: INITIAL_Y };
  });
}
```

### é—®é¢˜3ï¼šè¿çº¿é‡å 

**ç—‡çŠ¶**ï¼šå¤šæ¡è¿çº¿æ±‡å…¥åŒä¸€èŠ‚ç‚¹æ—¶é‡å ã€‚

**åŸå› **ï¼š
- æœªå¯ç”¨èµ°å»Šè·¯ç”±
- Handle åˆ†é…ä¸æ­£ç¡®

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. ç¡®ä¿ `incomingTotal` æ­£ç¡®ä¼ é€’
2. å¯ç”¨èµ°å»Šè·¯ç”±æœºåˆ¶
3. æ­£ç¡®åˆ†é… `targetHandle`

```typescript
// åœ¨ useFlowEdges ä¸­è®¾ç½® incomingTotal
edges.forEach(edge => {
  const incomingEdges = nodeIncomingEdges.get(edge.target) || [];
  flowEdges.push({
    ...edge,
    data: {
      ...edge.data,
      incomingTotal: incomingEdges.length,
    },
  });
});
```

### é—®é¢˜4ï¼šè¿çº¿é•¿åº¦ä¸å‡†ç¡®

**ç—‡çŠ¶**ï¼šè¿çº¿é•¿åº¦ä¸ç›®æ ‡å€¼ï¼ˆ120pxï¼‰åå·®è¾ƒå¤§ã€‚

**åŸå› **ï¼š
- èŠ‚ç‚¹å°ºå¯¸åœ¨å¸ƒå±€åå‘ç”Ÿå˜åŒ–
- é¦–æ¬¡å¸ƒå±€æ—¶èŠ‚ç‚¹å°ºå¯¸æœªå®Œå…¨æµ‹é‡

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å¯ç”¨é‡æ’è¿­ä»£æœºåˆ¶
2. å¢åŠ è¿­ä»£æ¬¡æ•°æˆ–è°ƒæ•´å®¹å·®

```typescript
const TOLERANCE = 5; // å…è®¸è¯¯å·® 5px
const MAX_ITERATIONS = 3; // æœ€å¤šé‡æ’ 3 æ¬¡
```

### é—®é¢˜5ï¼šæ€§èƒ½é—®é¢˜

**ç—‡çŠ¶**ï¼šå¸ƒå±€è®¡ç®—è€—æ—¶è¿‡é•¿ï¼Œé¡µé¢å¡é¡¿ã€‚

**åŸå› **ï¼š
- èŠ‚ç‚¹æ•°é‡è¿‡å¤š
- å¸ƒå±€è®¡ç®—æœªä¼˜åŒ–

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. ä½¿ç”¨ `useMemo` ç¼“å­˜è®¡ç®—ç»“æœ
2. ä½¿ç”¨ `React.memo` é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
3. æ‰¹é‡æ›´æ–°èŠ‚ç‚¹ä½ç½®

```typescript
// ä½¿ç”¨ useMemo ç¼“å­˜
export const useFlowNodes = (): FlowNode[] => {
  return useMemo(() => {
    // è®¡ç®—èŠ‚ç‚¹...
  }, [processes, expandedProcesses, nodePositions]);
};

// ä½¿ç”¨ memo é¿å…é‡æ¸²æŸ“
export const CustomNode = memo(({ ... }: NodeProps) => {
  // ...
});
```

---

## æ•°æ®å­˜å‚¨æ ¼å¼

### 1. å†…å­˜æ•°æ®ç»“æ„ï¼ˆZustand Storeï¼‰

```typescript
interface RecipeStore {
  // ä¸»æ•°æ®ç»“æ„
  processes: Process[];           // å·¥è‰ºæ®µåˆ—è¡¨
  edges: RecipeEdge[];           // å·¥è‰ºæ®µé—´è¿çº¿
  metadata: {
    name: string;
    version: string;
    updatedAt: string;
  };
  
  // UIçŠ¶æ€
  hoveredNodeId: string | null;
  selectedNodeId: string | null;
  expandedProcesses: Set<string>; // å±•å¼€çš„å·¥è‰ºæ®µIDé›†åˆ
  
  // å¸ƒå±€ç¼“å­˜
  nodePositions: Record<string, { x: number; y: number }>; // èŠ‚ç‚¹ä½ç½®ç¼“å­˜
  nodeHeights: Record<string, number>; // èŠ‚ç‚¹é«˜åº¦ç¼“å­˜ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  nodeWidths: Record<string, number>; // èŠ‚ç‚¹å®½åº¦ç¼“å­˜ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  
  // ç‰ˆæœ¬æ§åˆ¶
  version: number;               // ä¹è§‚é”ç‰ˆæœ¬å·
  isSaving: boolean;             // ä¿å­˜çŠ¶æ€
}
```

### 2. æ•°æ®åº“å­˜å‚¨æ ¼å¼ï¼ˆSQLiteï¼‰

#### è¡¨ç»“æ„

```sql
CREATE TABLE recipes (
  id TEXT PRIMARY KEY,              -- é…æ–¹IDï¼ˆé»˜è®¤ 'default'ï¼‰
  metadata TEXT NOT NULL,           -- JSONå­—ç¬¦ä¸²ï¼š{ name, version, updatedAt }
  processes TEXT NOT NULL,          -- JSONå­—ç¬¦ä¸²ï¼šProcess[] æ•°ç»„
  edges TEXT NOT NULL,              -- JSONå­—ç¬¦ä¸²ï¼šRecipeEdge[] æ•°ç»„
  version INTEGER DEFAULT 1,        -- ä¹è§‚é”ç‰ˆæœ¬å·
  updated_at TEXT NOT NULL,         -- ISO 8601 æ—¶é—´æˆ³
  updated_by TEXT                   -- æœ€åæ›´æ–°ç”¨æˆ·ID
);
```

#### JSON æ•°æ®æ ¼å¼

**Process ç»“æ„**ï¼š

```json
{
  "id": "P1",
  "name": "ç³–é†‡ã€ä¸‰æ°¯è”—ç³–ç±»æº¶è§£æ¶²",
  "description": "å¯é€‰æè¿°",
  "node": {
    "id": "P1",
    "type": "processNode",
    "label": "ç³–é†‡ã€ä¸‰æ°¯è”—ç³–ç±»æº¶è§£æ¶²",
    "subSteps": [
      {
        "id": "P1-substep-1",
        "order": 1,
        "processType": "dissolution",
        "label": "æº¶è§£",
        "deviceCode": "é«˜æ…æ¡¶1",
        "ingredients": "ç³–é†‡ã€ä¸‰æ°¯è”—ç³–",
        "params": {
          "processType": "dissolution",
          "dissolutionParams": {
            "waterVolumeMode": "ratio",
            "waterRatio": { "min": 5, "max": 8 },
            "waterTemp": { "min": 60, "max": 80, "unit": "â„ƒ" },
            "stirringTime": { "value": 30, "unit": "min" },
            "stirringRate": "high",
            "transferType": "material"
          }
        }
      }
    ]
  }
}
```

**RecipeEdge ç»“æ„**ï¼š

```json
{
  "id": "e_P1-P6",
  "source": "P1",
  "target": "P6",
  "type": "sequenceEdge",
  "data": {
    "sequenceOrder": 1
  },
  "animated": true
}
```

**å®Œæ•´ RecipeSchema**ï¼š

```json
{
  "metadata": {
    "name": "é¥®æ–™ç”Ÿäº§å·¥è‰ºé…æ–¹",
    "version": "1.0.0",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "processes": [
    { /* Process å¯¹è±¡ */ },
    { /* Process å¯¹è±¡ */ }
  ],
  "edges": [
    { /* RecipeEdge å¯¹è±¡ */ },
    { /* RecipeEdge å¯¹è±¡ */ }
  ]
}
```

### 3. èŠ‚ç‚¹ä½ç½®å’Œå°ºå¯¸å­˜å‚¨

**æ³¨æ„**ï¼šèŠ‚ç‚¹ä½ç½®ã€é«˜åº¦ã€å®½åº¦**ä¸å­˜å‚¨åœ¨æ•°æ®åº“ä¸­**ï¼Œä»…ä¿å­˜åœ¨å†…å­˜ä¸­çš„ç¼“å­˜ä¸­ã€‚æ¯æ¬¡åŠ è½½é…æ–¹æ—¶ï¼Œç”±å¸ƒå±€ç®—æ³•é‡æ–°è®¡ç®—ã€‚

```typescript
// å†…å­˜ä¸­çš„å¸ƒå±€ç¼“å­˜
nodePositions: {
  "P1": { x: 150, y: 80 },
  "P1-substep-1": { x: 150, y: 200 },
  "P2": { x: 514, y: 80 },
  // ...
}

nodeHeights: {
  "P1": 120,
  "P1-substep-1": 180,  // ç²¾ç¡®è®¡ç®—çš„é«˜åº¦
  "P2": 120,
  // ...
}

nodeWidths: {
  "P1": 200,
  "P1-substep-1": 200,
  "P2": 280,  // æ ¹æ®è¾“å…¥æ•°é‡åˆ†æ¡£
  // ...
}
```

**ç”¨é€”**ï¼š
- `nodePositions`ï¼šReact Flow æ¸²æŸ“èŠ‚ç‚¹ä½ç½®
- `nodeHeights`ï¼šè°ƒè¯•æ¨¡å¼è®¡ç®—è¿çº¿é•¿åº¦
- `nodeWidths`ï¼šè°ƒè¯•æ¨¡å¼è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒåæ ‡

---

## ä»£ç å®ç°ç»†èŠ‚

### 1. ä¸»å¸ƒå±€æ§åˆ¶å™¨ (`LayoutController.tsx`) âœ… å·²å®ç°

**å®ç°ä½ç½®**ï¼š`src/components/graph/LayoutController.tsx`

#### è§¦å‘æ¡ä»¶

å¸ƒå±€è®¡ç®—åœ¨ä»¥ä¸‹æƒ…å†µè§¦å‘ï¼š

1. **èŠ‚ç‚¹åˆå§‹åŒ–å®Œæˆ**ï¼šä½¿ç”¨ `useNodesInitialized` ç­‰å¾… React Flow æµ‹é‡èŠ‚ç‚¹å°ºå¯¸
2. **å†…å®¹å˜åŒ–**ï¼šé€šè¿‡ `layoutTrigger` prop æ£€æµ‹å†…å®¹å˜åŒ–ï¼ˆå·¥è‰ºæ®µIDã€å­æ­¥éª¤IDã€å±•å¼€çŠ¶æ€ï¼‰
3. **é¦–æ¬¡å¸ƒå±€**ï¼šä½¿ç”¨ `hasLayoutedRef` ç¡®ä¿åªå¸ƒå±€ä¸€æ¬¡
4. **é‡æ’è¿­ä»£**ï¼šé€šè¿‡ `relayoutTrigger` state è§¦å‘é‡æ’

#### layoutTrigger ç”Ÿæˆé€»è¾‘

`layoutTrigger` æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ç­¾åï¼Œç”¨äºæ£€æµ‹å†…å®¹å˜åŒ–ï¼š

```typescript
// å†…å®¹å˜åŒ–è§¦å‘å™¨ - ç”¨äºæ£€æµ‹éœ€è¦é‡æ–°å¸ƒå±€çš„æƒ…å†µ
// åªåŒ…å«å½±å“å¸ƒå±€çš„ä¿¡æ¯ï¼šå·¥è‰ºæ®µIDã€å­æ­¥éª¤IDã€å±•å¼€çŠ¶æ€
const layoutTrigger = useMemo(() => {
  const processIds = processes.map(p => p.id).join(',');
  const subStepIds = processes.flatMap(p => p.node.subSteps.map(s => s.id)).join(',');
  const expandedIds = Array.from(expandedProcesses).sort().join(',');
  
  return `${processIds}|${subStepIds}|${expandedIds}`;
}, [processes, expandedProcesses]);
```

**è§¦å‘æœºåˆ¶**ï¼š

```typescript
// å†…å®¹å˜åŒ–æ—¶é‡ç½®å¸ƒå±€æ ‡è®°å’Œè¿­ä»£æ¬¡æ•°
if (layoutTrigger !== layoutTriggerRef.current) {
  hasLayoutedRef.current = false;
  layoutIterationRef.current = 0;
  layoutTriggerRef.current = layoutTrigger;
  setRelayoutTrigger(0); // é‡ç½®è§¦å‘å™¨
}
```

#### å¸ƒå±€æµç¨‹

```typescript
export function LayoutController({ onLayoutComplete, onNodesUpdate, layoutTrigger }: LayoutControllerProps) {
  const { getNodes, setNodes, getEdges, fitView } = useReactFlow();
  const nodesInitialized = useNodesInitialized();
  const hasLayoutedRef = useRef(false);

  useLayoutEffect(() => {
    // 1. ç­‰å¾…èŠ‚ç‚¹åˆå§‹åŒ–ï¼ˆReact Flow å·²æµ‹é‡å°ºå¯¸ï¼‰
    if (!nodesInitialized) return;
    
    // 2. æ£€æŸ¥æ˜¯å¦å·²å¸ƒå±€è¿‡
    if (hasLayoutedRef.current) return;

    const nodes = getNodes() as FlowNode[];
    const edges = getEdges() as RecipeEdge[];

    // 3. æ”¶é›†çœŸå®å°ºå¯¸ï¼ˆReact Flow æµ‹é‡çš„ï¼‰
    const nodeHeights: Record<string, number> = {};
    const nodeWidths: Record<string, number> = {};
    nodes.forEach(node => {
      nodeHeights[node.id] = node.height || 120;
      nodeWidths[node.id] = node.width || 200;
    });

    // 4. è¯†åˆ«å·¥è‰ºæ®µ
    const { parallelSegments, serialSegments, convergenceNode } = 
      identifyProcessSegments(nodes, edges);

    // 5. åŸºäº displayOrder åˆ†é… X åæ ‡ï¼ˆå­˜å‚¨ä¸ºä¸­å¿ƒç‚¹ï¼‰
    const nodePositions: Record<string, { x: number; y: number }> = {};
    const nodesByDisplayOrder: Record<number, FlowNode[]> = {};
    // ... åˆ†ç»„å’Œåˆ†é… X åæ ‡é€»è¾‘

    // 6. å¸ƒå±€å¹¶è¡Œæ®µï¼ˆè®¡ç®— Y åæ ‡ï¼‰
    const parallelYPositions = layoutParallelSegments(
      parallelSegments,
      nodeHeights,
      { targetEdgeLength: 120, initialY: 80 }
    );

    // 7. è®¡ç®—æ±‡èšç‚¹ä½ç½® (X å’Œ Y)
    let convergenceY = 80;
    let convergenceX = 0;
    if (convergenceNode) {
      convergenceY = calculateConvergenceY(
        parallelSegments,
        parallelYPositions,
        nodeHeights,
        120,
        'max'
      );
      // è®¡ç®—æ±‡èšç‚¹ X åæ ‡ï¼ˆåŠ æƒè´¨å¿ƒæ³•ï¼‰
      // ...
    }

    // 8. å¸ƒå±€ä¸²è¡Œæ®µ
    const serialYPositions = layoutSerialSegments(
      serialSegments,
      convergenceY + (convergenceNode ? nodeHeights[convergenceNode.id] || 120 : 0),
      nodeHeights,
      { targetEdgeLength: 120 }
    );

    // 9. åº”ç”¨ X åæ ‡åˆ°ä¸²è¡Œæ®µï¼ˆä¸æ±‡èšç‚¹å¯¹é½ï¼‰
    if (convergenceX > 0) {
      serialSegments.forEach(segment => {
        segment.nodes.forEach(node => {
          if (nodePositions[node.id]) {
            nodePositions[node.id].x = convergenceX;
          }
        });
      });
    }

    // 10. åˆå¹¶ Y åæ ‡
    Object.keys(parallelYPositions).forEach(nodeId => {
      if (nodePositions[nodeId]) {
        nodePositions[nodeId].y = parallelYPositions[nodeId];
      }
    });
    Object.keys(serialYPositions).forEach(nodeId => {
      if (nodePositions[nodeId]) {
        nodePositions[nodeId].y = serialYPositions[nodeId];
      }
    });

    // 11. è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆReact Flow ä½¿ç”¨å·¦ä¸Šè§’ï¼‰
    const layoutedNodes = nodes.map(node => {
      const pos = nodePositions[node.id];
      const width = nodeWidths[node.id] || 200;
      const height = nodeHeights[node.id] || 120;
      
      return {
        ...node,
        position: {
          x: pos.x - width / 2,  // ä¸­å¿ƒç‚¹ â†’ å·¦ä¸Šè§’
          y: pos.y - height / 2, // ä¸­å¿ƒç‚¹ â†’ å·¦ä¸Šè§’
        },
      };
    });

    // 12. æ›´æ–°èŠ‚ç‚¹ä½ç½®
    onNodesUpdate(layoutedNodes);
    setNodes(layoutedNodes);

    // 13. è°ƒç”¨ fitView å¹¶é€šçŸ¥å®Œæˆ
    window.requestAnimationFrame(() => {
      window.requestAnimationFrame(() => {
        fitView({ padding: 0.2, duration: 0 });
        hasLayoutedRef.current = true;
        onLayoutComplete();
      });
    });
  }, [nodesInitialized, getNodes, setNodes, getEdges, fitView, onLayoutComplete, onNodesUpdate]);

  return null; // Headless Component
}
```

#### åæ ‡ç³»ç»Ÿ

- **å†…éƒ¨è®¡ç®—**ï¼šä½¿ç”¨ä¸­å¿ƒç‚¹åæ ‡ï¼ˆ`{ x: centerX, y: centerY }`ï¼‰
- **æœ€ç»ˆè¾“å‡º**ï¼šè½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆReact Flow è¦æ±‚ï¼‰
- **è½¬æ¢å…¬å¼**ï¼š`å·¦ä¸Šè§’X = ä¸­å¿ƒX - å®½åº¦/2`ï¼Œ`å·¦ä¸Šè§’Y = ä¸­å¿ƒY - é«˜åº¦/2`

### 2. React Flow é›†æˆ

#### èŠ‚ç‚¹æ¸²æŸ“

èŠ‚ç‚¹ä½ç½®ä» `nodePositions` ç¼“å­˜ä¸­è¯»å–ï¼š

```typescript
export const useFlowNodes = (): FlowNode[] => {
  const nodePositions = useRecipeStore((state) => state.nodePositions);
  
  return useMemo(() => {
    const nodes: FlowNode[] = [];
    
    processes.forEach((process, index) => {
      const isExpanded = expandedProcesses.has(process.id);
      const displayOrder = index + 1;
      
      if (isExpanded) {
        // å±•å¼€æ¨¡å¼ï¼šä¸ºæ¯ä¸ªå­æ­¥éª¤åˆ›å»ºèŠ‚ç‚¹
        process.node.subSteps.forEach((subStep) => {
          nodes.push({
            id: subStep.id,
            type: 'subStepNode',
            position: nodePositions[subStep.id] || { x: 0, y: 0 },
            data: { subStep, processId: process.id, displayOrder }
          });
        });
      } else {
        // æŠ˜å æ¨¡å¼ï¼šåˆ›å»ºæ±‡æ€»èŠ‚ç‚¹
        nodes.push({
          id: process.id,
          type: 'processSummaryNode',
          position: nodePositions[process.id] || { x: 0, y: 0 },
          data: {
            processId: process.id,
            processName: process.name,
            subStepCount: process.node.subSteps.length,
            displayOrder
          }
        });
      }
    });
    
    return nodes;
  }, [processes, expandedProcesses, nodePositions]);
};
```

#### è¾¹æ¸²æŸ“

è¾¹çš„ `targetHandle` å’Œ `sourceHandle` æ ¹æ®è¾“å…¥/è¾“å‡ºæ•°é‡åŠ¨æ€åˆ†é…ï¼š

```typescript
export const useFlowEdges = (): RecipeEdge[] => {
  return useMemo(() => {
    const flowEdges: RecipeEdge[] = [];
    
    // 1. å¤„ç†å·¥è‰ºæ®µé—´è¿çº¿
    edges.forEach(edge => {
      // æ ¹æ®å±•å¼€çŠ¶æ€ç¡®å®šå®é™…çš„ source/target èŠ‚ç‚¹ID
      const sourceNodeId = sourceExpanded 
        ? sourceProcess.node.subSteps[sourceProcess.node.subSteps.length - 1].id
        : sourceProcess.id;
      const targetNodeId = targetExpanded
        ? targetProcess.node.subSteps[0].id
        : targetProcess.id;
      
      flowEdges.push({ ...edge, source: sourceNodeId, target: targetNodeId });
    });
    
    // 2. å¤„ç†å·¥è‰ºæ®µå†…éƒ¨è¿çº¿ï¼ˆå±•å¼€æ—¶ï¼‰
    processes.forEach(process => {
      if (expandedProcesses.has(process.id) && process.node.subSteps.length > 1) {
        for (let idx = 0; idx < process.node.subSteps.length - 1; idx++) {
          flowEdges.push({
            id: `internal-${current.id}-${next.id}`,
            source: current.id,
            target: next.id,
            type: 'sequenceEdge',
            data: { sequenceOrder: 1 }
          });
        }
      }
    });
    
    // 3. åˆ†é… targetHandle å’Œ sourceHandle
    return flowEdges.map(edge => {
      const incomingEdges = nodeIncomingEdges.get(edge.target) || [];
      let targetHandle: string | undefined;
      
      if (incomingEdges.length > 1) {
        const sortedInEdges = [...incomingEdges].sort((a, b) => 
          (a.data?.sequenceOrder || 0) - (b.data?.sequenceOrder || 0)
        );
        const handleIndex = sortedInEdges.findIndex(e => e.id === edge.id);
        if (handleIndex >= 0) targetHandle = `target-${handleIndex}`;
      }
      
      // sourceHandle ç±»ä¼¼é€»è¾‘...
      
      return { ...edge, targetHandle, sourceHandle };
    });
  }, [processes, edges, expandedProcesses, nodePositions]);
};
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜æœºåˆ¶

#### ä½ç½®ç¼“å­˜

è®¡ç®—å¥½çš„ä½ç½®ä¼šå®æ—¶æ›´æ–°åˆ° `useRecipeStore` çš„ `nodePositions` ç¼“å­˜ä¸­ï¼Œé˜²æ­¢é¡µé¢åˆ·æ–°æŠ–åŠ¨ã€‚

```typescript
// åœ¨ RecipeFlow ä¸­åˆå¹¶ä½ç½®
useEffect(() => {
  setNodesState(prevNodesState => {
    // åˆ›å»ºä½ç½®æ˜ å°„è¡¨
    const positionMap = new Map(
      prevNodesState.map(n => [n.id, n.position])
    );
    
    // åˆå¹¶ï¼šä½¿ç”¨æ–°çš„åŸºç¡€æ•°æ®ï¼Œä½†ä¿ç•™ç°æœ‰èŠ‚ç‚¹çš„ä½ç½®
    const mergedNodes = baseNodes.map(baseNode => ({
      ...baseNode,
      position: positionMap.get(baseNode.id) ?? baseNode.position ?? { x: 0, y: 0 },
    }));
    
    return mergedNodes;
  });
}, [baseNodes]);
```

#### ç­¾åæ¯”è¾ƒ

ä½¿ç”¨ `layoutTrigger` å­—ç¬¦ä¸²ç­¾åæ£€æµ‹å†…å®¹å˜åŒ–ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°è®¡ç®—ï¼š

```typescript
const layoutTrigger = useMemo(() => {
  const processIds = processes.map(p => p.id).join(',');
  const subStepIds = processes.flatMap(p => p.node.subSteps.map(s => s.id)).join(',');
  const expandedIds = Array.from(expandedProcesses).sort().join(',');
  
  return `${processIds}|${subStepIds}|${expandedIds}`;
}, [processes, expandedProcesses]);
```

**ä¼˜åŠ¿**ï¼š
- âœ… å­—ç¬¦ä¸²æ¯”è¾ƒæ¯”å¯¹è±¡æ·±åº¦æ¯”è¾ƒæ›´å¿«
- âœ… åªåŒ…å«å½±å“å¸ƒå±€çš„å…³é”®ä¿¡æ¯
- âœ… é¿å…å› å¼•ç”¨å˜åŒ–å¯¼è‡´çš„è¯¯è§¦å‘

### 2. è®¡ç®—ä¼˜åŒ–

#### æŒ‰éœ€è®¡ç®—

åªåœ¨æ•°æ®å˜åŒ–æ—¶è§¦å‘å¸ƒå±€è®¡ç®—ï¼š

```typescript
// å†…å®¹å˜åŒ–æ—¶é‡ç½®å¸ƒå±€æ ‡è®°
if (layoutTrigger !== layoutTriggerRef.current) {
  hasLayoutedRef.current = false;
  layoutIterationRef.current = 0;
  layoutTriggerRef.current = layoutTrigger;
  setRelayoutTrigger(0);
}
```

#### æ‰¹é‡æ›´æ–°

æ‰€æœ‰ä½ç½®è®¡ç®—å®Œæˆåï¼Œä¸€æ¬¡æ€§æ›´æ–° Storeï¼š

```typescript
// æ‰€æœ‰ä½ç½®è®¡ç®—å®Œæˆåï¼Œä¸€æ¬¡æ€§æ›´æ–°
onNodesUpdate(layoutedNodes);
setNodes(layoutedNodes);
```

**ä¼˜åŠ¿**ï¼š
- âœ… å‡å°‘ React é‡æ¸²æŸ“æ¬¡æ•°
- âœ… é¿å…ä¸­é—´çŠ¶æ€çš„é—ªçƒ
- âœ… æé«˜æ€§èƒ½

### 3. React ä¼˜åŒ–

#### useMemo ç¼“å­˜

`useFlowNodes` å’Œ `useFlowEdges` ä½¿ç”¨ `useMemo` ç¼“å­˜ç»“æœï¼š

```typescript
export const useFlowNodes = (): FlowNode[] => {
  const nodePositions = useRecipeStore((state) => state.nodePositions);
  
  return useMemo(() => {
    const nodes: FlowNode[] = [];
    
    processes.forEach((process, index) => {
      const isExpanded = expandedProcesses.has(process.id);
      const displayOrder = index + 1;
      
      if (isExpanded) {
        // å±•å¼€æ¨¡å¼ï¼šä¸ºæ¯ä¸ªå­æ­¥éª¤åˆ›å»ºèŠ‚ç‚¹
        process.node.subSteps.forEach((subStep) => {
          nodes.push({
            id: subStep.id,
            type: 'subStepNode',
            position: nodePositions[subStep.id] || { x: 0, y: 0 },
            data: { subStep, processId: process.id, displayOrder }
          });
        });
      } else {
        // æŠ˜å æ¨¡å¼ï¼šåˆ›å»ºæ±‡æ€»èŠ‚ç‚¹
        nodes.push({
          id: process.id,
          type: 'processSummaryNode',
          position: nodePositions[process.id] || { x: 0, y: 0 },
          data: {
            processId: process.id,
            processName: process.name,
            subStepCount: process.node.subSteps.length,
            displayOrder
          }
        });
      }
    });
    
    return nodes;
  }, [processes, expandedProcesses, nodePositions]);
};
```

#### React.memo é¿å…é‡æ¸²æŸ“

`CustomNode` å’Œ `SequenceEdge` ä½¿ç”¨ `React.memo` é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“ï¼š

```typescript
export const CustomNode = memo(({ id, data, selected, type }: NodeProps<CustomNodeData>) => {
  // ...
});

export const SequenceEdge = memo(({ ... }: EdgeProps) => {
  // ...
});
```

**ä¼˜åŠ¿**ï¼š
- âœ… å‡å°‘ä¸å¿…è¦çš„ç»„ä»¶é‡æ¸²æŸ“
- âœ… æé«˜æ¸²æŸ“æ€§èƒ½
- âœ… å‡å°‘ CPU å ç”¨

### 4. å¸ƒå±€ç®—æ³•ä¼˜åŒ–

#### çœŸå®å°ºå¯¸æµ‹é‡

ä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡çš„èŠ‚ç‚¹å°ºå¯¸ï¼Œæ— éœ€ä¼°ç®—ï¼š

```typescript
// React Flow 11 ä¸­èŠ‚ç‚¹å°ºå¯¸å­˜å‚¨åœ¨ node.width å’Œ node.height
const nodeHeights: Record<string, number> = {};
const nodeWidths: Record<string, number> = {};
nodes.forEach(node => {
  nodeHeights[node.id] = node.height || 120;
  nodeWidths[node.id] = node.width || 200;
});
```

**ä¼˜åŠ¿**ï¼š
- âœ… ä½¿ç”¨å®é™…æ¸²æŸ“å°ºå¯¸ï¼Œæ— éœ€ä¼°ç®—
- âœ… è‡ªåŠ¨é€‚åº”å†…å®¹å˜åŒ–
- âœ… æ”¯æŒåŠ¨æ€å†…å®¹ï¼ˆå±•å¼€/æŠ˜å ï¼‰

#### åæ ‡ç³»ç»Ÿä¼˜åŒ–

å†…éƒ¨ä½¿ç”¨ä¸­å¿ƒç‚¹åæ ‡è®¡ç®—ï¼Œæœ€åè½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼š

```typescript
// å†…éƒ¨è®¡ç®—ï¼šä½¿ç”¨ä¸­å¿ƒç‚¹åæ ‡
nodePositions[node.id] = { x: laneX + width / 2, y: currentY };

// æœ€ç»ˆè¾“å‡ºï¼šè½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆReact Flow è¦æ±‚ï¼‰
position: {
  x: pos.x - width / 2,  // ä¸­å¿ƒç‚¹ â†’ å·¦ä¸Šè§’
  y: pos.y - height / 2, // ä¸­å¿ƒç‚¹ â†’ å·¦ä¸Šè§’
}
```

**ä¼˜åŠ¿**ï¼š
- âœ… ä¸­å¿ƒç‚¹åæ ‡è®¡ç®—æ›´ç›´è§‚
- âœ… å‡å°‘åæ ‡è½¬æ¢é”™è¯¯
- âœ… ä¾¿äºè°ƒè¯•

#### å¸ƒå±€è§¦å‘ä¼˜åŒ–

åŸºäºå†…å®¹å˜åŒ–è§¦å‘å™¨ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°è®¡ç®—ï¼š

```typescript
// ä½¿ç”¨ useLayoutEffect ç¡®ä¿åœ¨ DOM æ›´æ–°åæ‰§è¡Œ
useLayoutEffect(() => {
  // æ¡ä»¶1: èŠ‚ç‚¹å·²åˆå§‹åŒ–
  if (!nodesInitialized) return;
  
  // æ¡ä»¶2: è¿˜æ²¡æœ‰å¸ƒå±€è¿‡
  if (hasLayoutedRef.current) return;
  
  // æ‰§è¡Œå¸ƒå±€è®¡ç®—...
}, [nodesInitialized, getNodes, setNodes, getEdges, fitView, onLayoutComplete, onNodesUpdate, relayoutTrigger]);
```

**ä¼˜åŠ¿**ï¼š
- âœ… åªåœ¨å¿…è¦æ—¶æ‰§è¡Œå¸ƒå±€è®¡ç®—
- âœ… é¿å…é‡å¤è®¡ç®—
- âœ… æé«˜æ€§èƒ½

### 5. è°ƒè¯•æ¨¡å¼ä¼˜åŒ–

è°ƒè¯•æ¨¡å¼ä½¿ç”¨ `useMemo` ç¼“å­˜è®¡ç®—ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—ï¼š

```typescript
const debugLabels = useMemo((): DebugLabel[] => {
  if (!enabled) return [];
  
  // è®¡ç®—è°ƒè¯•æ ‡ç­¾...
  return labels;
}, [enabled, edges, getNodes]);
```

**ä¼˜åŠ¿**ï¼š
- âœ… åªåœ¨è°ƒè¯•æ¨¡å¼å¯ç”¨æ—¶è®¡ç®—
- âœ… ç¼“å­˜è®¡ç®—ç»“æœ
- âœ… å‡å°‘æ€§èƒ½å¼€é”€

---

## æ€»ç»“

æœ¬è‡ªåŠ¨å¸ƒå±€ç®—æ³•é‡‡ç”¨**å·¥è‰ºæ®µè¯†åˆ« + åˆ†æ®µå¸ƒå±€**çš„ç­–ç•¥ï¼Œèƒ½å¤Ÿï¼š

1. âœ… è‡ªåŠ¨è¯†åˆ«å¹¶è¡Œå’Œä¸²è¡Œå·¥è‰ºæ®µ
2. âœ… ç¡®ä¿è¿çº¿é•¿åº¦ç»Ÿä¸€ï¼ˆ120pxï¼‰
3. âœ… ä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡çš„çœŸå®èŠ‚ç‚¹å°ºå¯¸
4. âœ… åŸºäºè¡¨æ ¼é¡ºåºï¼ˆ`displayOrder`ï¼‰è¿›è¡Œæ°´å¹³å¯¹é½
5. âœ… æ™ºèƒ½å¤„ç†æ±‡èšç‚¹çš„å±…ä¸­ï¼ˆåŠ æƒè´¨å¿ƒç®—æ³•ï¼‰
6. âœ… æä¾›è°ƒè¯•æ¨¡å¼å¯è§†åŒ–å¸ƒå±€é—®é¢˜

ç®—æ³•å…·æœ‰è‰¯å¥½çš„å¯æ‰©å±•æ€§å’Œæ€§èƒ½ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„å·¥è‰ºæµç¨‹å›¾å½¢å¸ƒå±€éœ€æ±‚ã€‚

---

## ç›¸å…³æ–‡ä»¶

### æ ¸å¿ƒå¸ƒå±€æ–‡ä»¶

- `src/components/graph/LayoutController.tsx` - ä¸»å¸ƒå±€æ§åˆ¶å™¨ï¼ˆHeadless Componentï¼‰
- `src/components/graph/RecipeFlow.tsx` - React Flow ç»„ä»¶ï¼ˆé›†æˆå¸ƒå±€æ§åˆ¶å™¨ï¼‰
- `src/hooks/segmentIdentifier.ts` - å·¥è‰ºæ®µè¯†åˆ«ç®—æ³•
- `src/hooks/segmentLayoutCalculator.ts` - åˆ†æ®µå¸ƒå±€è®¡ç®—å™¨

### è°ƒè¯•ç»„ä»¶

- `src/components/graph/DebugOverlay.tsx` - è°ƒè¯•å åŠ å±‚ç»„ä»¶ï¼ˆæ˜¾ç¤ºè¿çº¿é•¿åº¦ï¼‰
- `src/components/graph/DebugStatsPanel.tsx` - è°ƒè¯•ç»Ÿè®¡é¢æ¿ï¼ˆæ˜¾ç¤ºå¸ƒå±€ç»Ÿè®¡ï¼‰

### èŠ‚ç‚¹ç»„ä»¶

- `src/components/graph/CustomNode.tsx` - è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶ï¼ˆåŒ…å«åˆ†æ¡£å®½åº¦è®¡ç®—ï¼‰

### çŠ¶æ€ç®¡ç†

- `src/store/useRecipeStore.ts` - çŠ¶æ€ç®¡ç†ï¼ˆåŒ…å«èŠ‚ç‚¹ä½ç½®ç¼“å­˜ï¼‰

### ç±»å‹å®šä¹‰

- `src/types/recipe.ts` - ç±»å‹å®šä¹‰ï¼ˆFlowNode, RecipeEdge, ProcessSegment ç­‰ï¼‰

### æ•°æ®åº“

- `server/src/db.ts` - æ•°æ®åº“æ“ä½œ

---

## å®ç°çŠ¶æ€è¯´æ˜

### å·²å®ç°åŠŸèƒ½ âœ…

1. **å·¥è‰ºæ®µè¯†åˆ«**ï¼šå®Œæ•´å®ç°ï¼Œä½¿ç”¨ DFS ç®—æ³•è¯†åˆ«å¹¶è¡Œå’Œä¸²è¡Œå·¥è‰ºæ®µ
2. **å¹¶è¡Œæ®µå¸ƒå±€**ï¼šå®Œæ•´å®ç°ï¼ŒæŒ‰å·¥è‰ºç±»å‹åˆ†ç»„å¯¹é½ï¼Œèƒå–ç±»è‡ªé€‚åº”å‹ç¼©
3. **ä¸²è¡Œæ®µå¸ƒå±€**ï¼šå®Œæ•´å®ç°ï¼Œä»æ±‡èšç‚¹å‘ä¸‹æ’åˆ—
4. **æ±‡èšç‚¹è®¡ç®—**ï¼šå®Œæ•´å®ç°ï¼Œæ”¯æŒ Y åæ ‡ï¼ˆmax/weighted/median ç­–ç•¥ï¼‰å’Œ X åæ ‡ï¼ˆåŠ æƒè´¨å¿ƒï¼Œå¹³æ–¹æ ¹æƒé‡ï¼‰
5. **å¸ƒå±€å¸é™„æœºåˆ¶**ï¼šå®Œæ•´å®ç°ï¼Œæ±‡èšç‚¹è‡ªåŠ¨å¸é™„åˆ°å…¥è¾¹æºèŠ‚ç‚¹Xåæ ‡
6. **åœ†è§’å¯è¡Œæ€§æ£€æŸ¥**ï¼šå®Œæ•´å®ç°ï¼Œç¡®ä¿è¿çº¿æœ‰è¶³å¤Ÿæ°´å¹³ç©ºé—´ç”»åœ†è§’
7. **æ°´å¹³å¸ƒå±€**ï¼šå®Œæ•´å®ç°ï¼ŒåŸºäº `displayOrder` åˆ†é…æ°´å¹³è½¦é“
8. **åˆ†æ¡£å®½åº¦**ï¼šå®Œæ•´å®ç°ï¼Œåœ¨ `CustomNode.tsx` ä¸­æ ¹æ®è¾“å…¥æ•°é‡è®¡ç®—
9. **èŠ‚ç‚¹å°ºå¯¸è·å–**ï¼šå®Œæ•´å®ç°ï¼Œä½¿ç”¨ React Flow è‡ªåŠ¨æµ‹é‡
10. **æµ‹é‡é‡è¯•æœºåˆ¶**ï¼šå®Œæ•´å®ç°ï¼Œæœ€å¤šé‡è¯•5æ¬¡
11. **è°ƒè¯•æ¨¡å¼**ï¼šå®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬å¯è§†åŒ–å åŠ å±‚å’Œç»Ÿè®¡é¢æ¿

### å®ç°å·®å¼‚è¯´æ˜

1. **å¸ƒå±€å…¥å£**ï¼š
   - **æ–‡æ¡£æè¿°**ï¼š`useAutoLayout.ts` hook
   - **å®é™…å®ç°**ï¼š`LayoutController.tsx` Headless Component
   - **åŸå› **ï¼šéœ€è¦åœ¨ React Flow å†…éƒ¨ä½¿ç”¨ `useReactFlow` å’Œ `useNodesInitialized`

2. **èŠ‚ç‚¹å°ºå¯¸è®¡ç®—**ï¼š
   - **æ–‡æ¡£æè¿°**ï¼šCanvas API ç²¾ç¡®æµ‹é‡æ–‡å­—é«˜åº¦
   - **å®é™…å®ç°**ï¼šReact Flow è‡ªåŠ¨æµ‹é‡çš„çœŸå®å°ºå¯¸
   - **åŸå› **ï¼šReact Flow 11 æä¾›äº†è‡ªåŠ¨å°ºå¯¸æµ‹é‡ï¼Œæ›´å‡†ç¡®ä¸”æ— éœ€ç»´æŠ¤

3. **åæ ‡ç³»ç»Ÿ**ï¼š
   - **å†…éƒ¨è®¡ç®—**ï¼šä½¿ç”¨ä¸­å¿ƒç‚¹åæ ‡
   - **æœ€ç»ˆè¾“å‡º**ï¼šè½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆReact Flow è¦æ±‚ï¼‰
   - **æ–‡æ¡£è¯´æ˜**ï¼šå·²æ›´æ–°ä»¥åæ˜ å®é™…å®ç°

---

## æ›´æ–°æ—¥å¿—

### 2026-01-12ï¼šæ–‡æ¡£å…¨é¢æ›´æ–°

**æ›´æ–°å†…å®¹**:
- âœ… æ›´æ–°å¹¶è¡Œæ®µå¸ƒå±€ç®—æ³•æè¿°ï¼Œæ·»åŠ æŒ‰å·¥è‰ºç±»å‹åˆ†ç»„å¯¹é½ç­–ç•¥
- âœ… æ·»åŠ èƒå–ç±»è‡ªé€‚åº”è¾¹è·å‹ç¼©å…¬å¼ï¼š`edgeLen(n) = clamp(base * s * sqrt(3 / max(n, 3)), minEdge, base)`
- âœ… ä¿®æ­£æ±‡èšç‚¹Xåæ ‡æƒé‡å…¬å¼ä¸º `Math.sqrt(validNodes.length)`
- âœ… æ·»åŠ å¸ƒå±€å¸é™„æœºåˆ¶æè¿°ï¼ˆå¸é™„é˜ˆå€¼ã€åœ†è§’å¯è¡Œæ€§æ£€æŸ¥ï¼‰
- âœ… æ·»åŠ æµ‹é‡é‡è¯•æœºåˆ¶æè¿°ï¼ˆæœ€å¤š5æ¬¡é‡è¯•ï¼‰
- âœ… æ›´æ–°å®ç°çŠ¶æ€æ€»è§ˆè¡¨

**ä¸»è¦å˜æ›´**:
- å¹¶è¡Œæ®µå¸ƒå±€ä»"å›ºå®šè¿çº¿é•¿åº¦"æ›´æ­£ä¸º"æŒ‰å·¥è‰ºç±»å‹åˆ†ç»„å¯¹é½"
- æ±‡èšç‚¹Xåæ ‡æƒé‡ä»"èŠ‚ç‚¹æ•°é‡"æ›´æ­£ä¸º"èŠ‚ç‚¹æ•°é‡çš„å¹³æ–¹æ ¹"
- æ–°å¢å¸ƒå±€å¸é™„æœºåˆ¶ç« èŠ‚ï¼ˆ4.3èŠ‚ï¼‰
- æ–°å¢æµ‹é‡é‡è¯•æœºåˆ¶ç« èŠ‚

### 2024-XX-XXï¼šæ–‡æ¡£åˆå§‹åŒ–

**æ›´æ–°å†…å®¹**:
- âœ… åˆ›å»ºæ–‡æ¡£ï¼Œæè¿°è‡ªåŠ¨å¸ƒå±€ç®—æ³•çš„åŸºæœ¬æ¶æ„
- âœ… æ·»åŠ å·¥è‰ºæ®µè¯†åˆ«ç®—æ³•è¯¦è§£
- âœ… æ·»åŠ åˆ†æ®µå¸ƒå±€è®¡ç®—å™¨æè¿°
- âœ… æ·»åŠ è°ƒè¯•æ¨¡å¼è¯´æ˜

