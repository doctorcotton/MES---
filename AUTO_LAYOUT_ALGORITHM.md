# è‡ªåŠ¨å¸ƒå±€ç®—æ³•è¯¦ç»†æ–‡æ¡£

## ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æŠ€æœ¯è·¯çº¿](#æŠ€æœ¯è·¯çº¿)
3. [ç®—æ³•æ¶æ„](#ç®—æ³•æ¶æ„)
4. [æ ¸å¿ƒç®—æ³•è¯¦è§£](#æ ¸å¿ƒç®—æ³•è¯¦è§£)
5. [ç²¾ç¡®é«˜åº¦è®¡ç®—](#ç²¾ç¡®é«˜åº¦è®¡ç®—)
6. [è°ƒè¯•æ¨¡å¼](#è°ƒè¯•æ¨¡å¼)
7. [æ•°æ®å­˜å‚¨æ ¼å¼](#æ•°æ®å­˜å‚¨æ ¼å¼)
8. [ä»£ç å®ç°ç»†èŠ‚](#ä»£ç å®ç°ç»†èŠ‚)
9. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## æ¦‚è¿°

æœ¬ç³»ç»Ÿå®ç°äº†ä¸€ä¸ªæ™ºèƒ½çš„å·¥è‰ºæµç¨‹å›¾è‡ªåŠ¨å¸ƒå±€ç®—æ³•ï¼Œç”¨äºè‡ªåŠ¨è®¡ç®—å’Œæ’åˆ—é…æ–¹å·¥è‰ºæµç¨‹å›¾ä¸­çš„èŠ‚ç‚¹ä½ç½®ã€‚ç®—æ³•é‡‡ç”¨**å·¥è‰ºæ®µè¯†åˆ« + åˆ†æ®µå¸ƒå±€**çš„ç­–ç•¥ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„å¹¶è¡Œ-ä¸²è¡Œæ··åˆæµç¨‹ï¼Œç¡®ä¿è¿çº¿é•¿åº¦å‡åŒ€ã€è§†è§‰ç¾è§‚ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å·¥è‰ºæ®µè‡ªåŠ¨è¯†åˆ«**ï¼šè‡ªåŠ¨è¯†åˆ«å¹¶è¡Œå·¥è‰ºæ®µå’Œä¸²è¡Œå·¥è‰ºæ®µ
- âœ… **åˆ†æ®µå¸ƒå±€è®¡ç®—**ï¼šå¹¶è¡Œæ®µå’Œä¸²è¡Œæ®µé‡‡ç”¨ä¸åŒçš„å¸ƒå±€ç­–ç•¥
- âœ… **å›ºå®šè¿çº¿é•¿åº¦**ï¼šç¡®ä¿æ‰€æœ‰è¿çº¿é•¿åº¦ç»Ÿä¸€ï¼ˆç›®æ ‡å€¼ï¼š120pxï¼‰
- âœ… **ç²¾ç¡®é«˜åº¦è®¡ç®—**ï¼šä½¿ç”¨ Canvas API ç²¾ç¡®æµ‹é‡æ–‡å­—é«˜åº¦ï¼Œè¯¯å·® < 2px
- âœ… **æ™ºèƒ½èŠ‚ç‚¹å°ºå¯¸**ï¼šæ ¹æ®è¾“å…¥æ•°é‡å’Œå†…å®¹åŠ¨æ€è®¡ç®—èŠ‚ç‚¹å®½é«˜
- âœ… **æ°´å¹³å¯¹é½ä¼˜åŒ–**ï¼šåŸºäº `displayOrder` çš„æ°´å¹³å¯¹é½
- âœ… **æ±‡èšç‚¹æ™ºèƒ½å±…ä¸­**ï¼šå¤šè¾“å…¥èŠ‚ç‚¹çš„åŠ æƒå±…ä¸­ç®—æ³•
- âœ… **è°ƒè¯•æ¨¡å¼**ï¼šå¯è§†åŒ–æ˜¾ç¤ºè¿çº¿é•¿åº¦å’Œè¯¯å·®ï¼Œå¿«é€Ÿå®šä½å¸ƒå±€é—®é¢˜

---

## æŠ€æœ¯è·¯çº¿

### æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|
| **React Flow** | 11.11.0 | æµç¨‹å›¾æ¸²æŸ“å¼•æ“ |
| **Dagre** | 0.8.5 | åŸºç¡€å›¾å½¢å¸ƒå±€ç®—æ³•ï¼ˆç”¨äºåˆå§‹æ°´å¹³å¸ƒå±€ï¼‰ |
| **TypeScript** | 5.2.2 | ç±»å‹å®‰å…¨ |
| **Zustand** | 4.5.0 | çŠ¶æ€ç®¡ç† |
| **React Hooks** | - | å“åº”å¼å¸ƒå±€è®¡ç®— |

### ç®—æ³•æµç¨‹

```mermaid
flowchart TD
    A[å¼€å§‹å¸ƒå±€è®¡ç®—] --> B[è¯†åˆ«å·¥è‰ºæ®µ]
    B --> C{æ˜¯å¦ä½¿ç”¨å·¥è‰ºæ®µå¸ƒå±€?}
    C -->|æ˜¯| D[å¹¶è¡Œæ®µå¸ƒå±€]
    C -->|å¦| E[DagreåŸºç¡€å¸ƒå±€]
    D --> F[è®¡ç®—æ±‡èšç‚¹Yåæ ‡]
    F --> G[ä¸²è¡Œæ®µå¸ƒå±€]
    G --> H[è®¡ç®—èŠ‚ç‚¹å°ºå¯¸]
    H --> I[æ°´å¹³å¯¹é½ä¼˜åŒ–]
    I --> J[æ±‡èšç‚¹å±…ä¸­]
    J --> K[å‹ç¼©å¹¶è¡Œåˆ†æ”¯]
    K --> L[ä¿å­˜ä½ç½®åˆ°Store]
    E --> H
    L --> M[ç»“æŸ]
```

---

## ç®—æ³•æ¶æ„

### æ¨¡å—åˆ’åˆ†

```
src/hooks/
â”œâ”€â”€ useAutoLayout.ts          # ä¸»å¸ƒå±€é’©å­ï¼ˆå…¥å£ï¼‰
â”œâ”€â”€ segmentIdentifier.ts      # å·¥è‰ºæ®µè¯†åˆ«ç®—æ³•
â””â”€â”€ segmentLayoutCalculator.ts # åˆ†æ®µå¸ƒå±€è®¡ç®—å™¨
```

### æ•°æ®æµ

```mermaid
sequenceDiagram
    participant Store as RecipeStore
    participant Hook as useAutoLayout
    participant Identifier as segmentIdentifier
    participant Calculator as segmentLayoutCalculator
    participant Dagre as Dagre Graph
    participant ReactFlow as React Flow

    Store->>Hook: èŠ‚ç‚¹/è¾¹æ•°æ®å˜åŒ–
    Hook->>Identifier: è¯†åˆ«å·¥è‰ºæ®µ
    Identifier-->>Hook: å¹¶è¡Œæ®µ + ä¸²è¡Œæ®µ
    Hook->>Calculator: å¸ƒå±€å¹¶è¡Œæ®µ
    Calculator-->>Hook: å¹¶è¡Œæ®µYåæ ‡
    Hook->>Calculator: è®¡ç®—æ±‡èšç‚¹Y
    Calculator-->>Hook: æ±‡èšç‚¹Yåæ ‡
    Hook->>Calculator: å¸ƒå±€ä¸²è¡Œæ®µ
    Calculator-->>Hook: ä¸²è¡Œæ®µYåæ ‡
    Hook->>Dagre: è®¡ç®—åˆå§‹æ°´å¹³å¸ƒå±€
    Dagre-->>Hook: åˆå§‹Xåæ ‡
    Hook->>Hook: æ°´å¹³å¯¹é½ä¼˜åŒ–
    Hook->>Hook: æ±‡èšç‚¹å±…ä¸­
    Hook->>Store: ä¿å­˜æœ€ç»ˆä½ç½®
    Store->>ReactFlow: æ›´æ–°èŠ‚ç‚¹ä½ç½®
```

---

## æ ¸å¿ƒç®—æ³•è¯¦è§£

### 1. å·¥è‰ºæ®µè¯†åˆ«ç®—æ³• (`segmentIdentifier.ts`)

#### ç®—æ³•åŸç†

å·¥è‰ºæ®µè¯†åˆ«é‡‡ç”¨**æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰**ç­–ç•¥ï¼Œä»èµ·ç‚¹èŠ‚ç‚¹å¼€å§‹éå†ï¼Œç›´åˆ°é‡åˆ°æ±‡èšç‚¹æˆ–ç»ˆç‚¹ã€‚

#### è¯†åˆ«è§„åˆ™

1. **èµ·ç‚¹èŠ‚ç‚¹**ï¼šå…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹
2. **æ±‡èšç‚¹**ï¼šå…¥åº¦ > 1 çš„èŠ‚ç‚¹ï¼ˆå¤šä¸ªåˆ†æ”¯æ±‡èšï¼‰
3. **å¹¶è¡Œå·¥è‰ºæ®µ**ï¼šä»èµ·ç‚¹åˆ°æ±‡èšç‚¹ä¹‹é—´çš„è·¯å¾„
4. **ä¸²è¡Œå·¥è‰ºæ®µ**ï¼šæ±‡èšç‚¹ä¹‹åçš„è¿ç»­èŠ‚ç‚¹åºåˆ—

#### ä»£ç å®ç°

```typescript
// æ ¸å¿ƒè¯†åˆ«é€»è¾‘
export function identifyProcessSegments(
  nodes: FlowNode[],
  edges: RecipeEdge[]
): SegmentIdentificationResult {
  // 1. æ„å»ºå›¾ç»“æ„ï¼ˆé‚»æ¥è¡¨ï¼‰
  const outgoingEdges = new Map<string, RecipeEdge[]>();
  const incomingEdges = new Map<string, RecipeEdge[]>();
  
  // 2. æ‰¾åˆ°æ‰€æœ‰èµ·ç‚¹èŠ‚ç‚¹ï¼ˆå…¥åº¦ä¸º0ï¼‰
  const startNodes = nodes.filter(node => {
    const incoming = incomingEdges.get(node.id) || [];
    return incoming.length === 0;
  });
  
  // 3. æ‰¾åˆ°æ±‡èšç‚¹ï¼ˆå…¥åº¦ > 1ï¼‰
  const convergenceNodes = nodes.filter(node => {
    const incoming = incomingEdges.get(node.id) || [];
    return incoming.length > 1;
  });
  
  // 4. ä»æ¯ä¸ªèµ·ç‚¹DFSï¼Œæ„å»ºå¹¶è¡Œå·¥è‰ºæ®µ
  const parallelSegments: ProcessSegment[] = [];
  startNodes.forEach((startNode, index) => {
    const segmentNodes: FlowNode[] = [];
    function dfs(currentNodeId: string): void {
      // å¦‚æœé‡åˆ°æ±‡èšç‚¹ï¼Œåœæ­¢éå†
      if (convergenceNode && currentNodeId === convergenceNode.id) {
        return;
      }
      // ç»§ç»­éå†å‡ºè¾¹...
    }
    dfs(startNode.id);
    parallelSegments.push({ ... });
  });
  
  // 5. è¯†åˆ«ä¸²è¡Œå·¥è‰ºæ®µï¼ˆæ±‡èšç‚¹ä¹‹åçš„èŠ‚ç‚¹ï¼‰
  // ...
}
```

#### è¯†åˆ«ç»“æœç»“æ„

```typescript
interface ProcessSegment {
  id: string;              // æ®µIDï¼Œå¦‚ "parallel-segment-0"
  nodes: FlowNode[];       // è¯¥æ®µçš„æ‰€æœ‰èŠ‚ç‚¹
  isParallel: boolean;     // æ˜¯å¦åœ¨å¹¶è¡ŒåŒºåŸŸ
  startNodeId: string;     // èµ·å§‹èŠ‚ç‚¹ID
  endNodeId: string;       // ç»“æŸèŠ‚ç‚¹ID
}
```

---

### 2. åˆ†æ®µå¸ƒå±€è®¡ç®—å™¨ (`segmentLayoutCalculator.ts`)

#### 2.1 å¹¶è¡Œæ®µå¸ƒå±€

**ç›®æ ‡**ï¼šæ‰€æœ‰å¹¶è¡Œæ®µèµ·ç‚¹Yåæ ‡ç›¸åŒï¼Œæ®µå†…è¿çº¿é•¿åº¦å›ºå®šã€‚

```typescript
export function layoutParallelSegments(
  segments: ProcessSegment[],
  nodeHeights: Record<string, number>,
  config: ParallelLayoutConfig
): Record<string, number> {
  const nodeYPositions: Record<string, number> = {};
  
  segments.forEach(segment => {
    let currentY = config.initialY; // æ‰€æœ‰æ®µä»åŒä¸€Yå¼€å§‹
    
    segment.nodes.forEach((node, idx) => {
      nodeYPositions[node.id] = currentY;
      
      if (idx < segment.nodes.length - 1) {
        const nextNode = segment.nodes[idx + 1];
        const currentNodeHeight = nodeHeights[node.id] || 120;
        const nextNodeHeight = nodeHeights[nextNode.id] || 120;
        
        // è®¡ç®—é—´è·ï¼šèŠ‚ç‚¹é«˜åº¦çš„ä¸€åŠ + ç›®æ ‡è¿çº¿é•¿åº¦ + ä¸‹ä¸ªèŠ‚ç‚¹é«˜åº¦çš„ä¸€åŠ
        const spacing =
          currentNodeHeight / 2 +      // å½“å‰èŠ‚ç‚¹åº•éƒ¨åˆ°ä¸­å¿ƒ
          config.targetEdgeLength +    // è¿çº¿é•¿åº¦ï¼ˆå›ºå®š120pxï¼‰
          nextNodeHeight / 2;          // ä¸‹ä¸ªèŠ‚ç‚¹ä¸­å¿ƒåˆ°é¡¶éƒ¨
        
        currentY += spacing;
      }
    });
  });
  
  return nodeYPositions;
}
```

**å¸ƒå±€ç¤ºæ„å›¾**ï¼š

```
å¹¶è¡Œæ®µ1:  [Node1] â”€â”€120pxâ”€â”€ [Node2] â”€â”€120pxâ”€â”€ [Node3]
         â†‘
         èµ·å§‹Y = 80

å¹¶è¡Œæ®µ2:  [Node4] â”€â”€120pxâ”€â”€ [Node5]
         â†‘
         èµ·å§‹Y = 80 (ä¸æ®µ1å¯¹é½)
```

#### 2.2 æ±‡èšç‚¹Yåæ ‡è®¡ç®—

**ç­–ç•¥**ï¼šé‡‡ç”¨ `max` ç­–ç•¥ï¼Œå–æ‰€æœ‰å¹¶è¡Œæ®µç»ˆç‚¹çš„æœ€å¤§Yåæ ‡ã€‚

```typescript
export function calculateConvergenceY(
  parallelSegments: ProcessSegment[],
  nodeYPositions: Record<string, number>,
  nodeHeights: Record<string, number>,
  targetEdgeLength: number,
  strategy: ConvergenceStrategy = 'max'
): number {
  // è®¡ç®—æ¯ä¸ªå¹¶è¡Œæ®µçš„ç»ˆç‚¹Yåæ ‡
  const endYs = parallelSegments.map(seg => {
    const lastNode = seg.nodes[seg.nodes.length - 1];
    const lastNodeY = nodeYPositions[lastNode.id];
    const lastNodeHeight = nodeHeights[lastNode.id] || 120;
    
    // ç»ˆç‚¹Y = èŠ‚ç‚¹ä¸­å¿ƒY + èŠ‚ç‚¹é«˜åº¦çš„ä¸€åŠ + è¿çº¿é•¿åº¦
    return lastNodeY + lastNodeHeight / 2 + targetEdgeLength;
  });
  
  switch (strategy) {
    case 'max':
      return Math.max(...endYs);  // æ¨èï¼šæ‰€æœ‰å…¥è¾¹éƒ½å‘ä¸‹
    case 'weighted':
      // æ ¹æ®å·¥è‰ºæ®µé•¿åº¦åŠ æƒå¹³å‡
      // ...
    case 'median':
      // å–ä¸­ä½æ•°
      // ...
  }
}
```

**å…¶ä»–ç­–ç•¥è¯´æ˜**ï¼š

- **`max`**ï¼ˆæ¨èï¼‰ï¼šæ‰€æœ‰å…¥è¾¹éƒ½å‘ä¸‹ï¼Œç¬¦åˆè§†è§‰ä¹ æƒ¯
- **`weighted`**ï¼šæ ¹æ®å·¥è‰ºæ®µé•¿åº¦åŠ æƒï¼Œé•¿æ®µæƒé‡æ›´å¤§
- **`median`**ï¼šå–æ‰€æœ‰åˆ†æ”¯ç»ˆç‚¹çš„ä¸­ä½æ•°

#### 2.3 ä¸²è¡Œæ®µå¸ƒå±€

**ç›®æ ‡**ï¼šä»æ±‡èšç‚¹å¼€å§‹ï¼Œå‚ç›´å‘ä¸‹æ’åˆ—ï¼Œæ‰€æœ‰è¿çº¿é•¿åº¦ç»Ÿä¸€ã€‚

```typescript
export function layoutSerialSegments(
  segments: ProcessSegment[],
  startY: number,  // æ±‡èšç‚¹ä¹‹åçš„èµ·å§‹Y
  nodeHeights: Record<string, number>,
  config: SerialLayoutConfig
): Record<string, number> {
  const nodeYPositions: Record<string, number> = {};
  let currentY = startY;
  
  segments.forEach(segment => {
    segment.nodes.forEach((node, idx) => {
      nodeYPositions[node.id] = currentY;
      
      if (idx < segment.nodes.length - 1) {
        const nextNode = segment.nodes[idx + 1];
        const spacing =
          nodeHeights[node.id] / 2 +
          config.targetEdgeLength +
          nodeHeights[nextNode.id] / 2;
        
        currentY += spacing;
      }
    });
  });
  
  return nodeYPositions;
}
```

---

### 3. èŠ‚ç‚¹å°ºå¯¸è®¡ç®— (`useAutoLayout.ts`)

#### 3.1 å®½åº¦è®¡ç®—ï¼ˆåˆ†æ¡£ç­–ç•¥ï¼‰

æ ¹æ®è¾“å…¥æ•°é‡åˆ†æ¡£ï¼š

```typescript
const widthTiers = {
  tier1: { maxInputs: 2, width: 200 },  // 1-2ä¸ªè¾“å…¥ï¼š200px
  tier2: { maxInputs: 4, width: 280 },   // 3-4ä¸ªè¾“å…¥ï¼š280px
  tier3: { maxInputs: Infinity, width: 360 } // 5ä¸ªåŠä»¥ä¸Šï¼š360px
};

function calculateTieredWidth(inputCount: number): number {
  if (inputCount <= 2) return 200;
  if (inputCount <= 4) return 280;
  return 360;
}
```

#### 3.2 é«˜åº¦è®¡ç®—ï¼ˆç²¾ç¡®æµ‹é‡ - Canvas APIï¼‰

**æ”¹è¿›**ï¼šä½¿ç”¨ Canvas API ç²¾ç¡®æµ‹é‡æ–‡å­—å®½åº¦ï¼Œæ›¿ä»£ç®€å•çš„å­—ç¬¦æ•°ä¼°ç®—ã€‚

**æ ¸å¿ƒå‡½æ•°**ï¼š

```typescript
/**
 * ä½¿ç”¨ Canvas API ç²¾ç¡®æµ‹é‡æ–‡å­—æ¢è¡Œ
 * è€ƒè™‘å®é™…å­—ä½“æ ·å¼ï¼Œæ”¯æŒä¸­è‹±æ–‡æ··æ’
 */
function wrapText(
  ctx: CanvasRenderingContext2D,
  text: string,
  maxWidth: number
): string[] {
  const lines: string[] = [];
  let currentLine = '';
  
  // æŒ‰å­—ç¬¦éå†ï¼ˆæ”¯æŒä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—ï¼‰
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const testLine = currentLine + char;
    const metrics = ctx.measureText(testLine);
    
    if (metrics.width > maxWidth && currentLine.length > 0) {
      lines.push(currentLine);
      currentLine = char;
    } else {
      currentLine = testLine;
    }
  }
  
  if (currentLine) lines.push(currentLine);
  return lines.length > 0 ? lines : [''];
}

/**
 * ä½¿ç”¨ Canvas API ç²¾ç¡®æµ‹é‡æ–‡æœ¬é«˜åº¦
 */
function measureTextHeight(
  text: string,
  availableWidth: number,
  fontSize: number = 12,
  fontFamily: string = 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
  lineHeight: number = 20
): { lineCount: number; totalHeight: number } {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  if (!ctx) {
    // Canvas ä¸å¯ç”¨æ—¶ï¼Œå›é€€åˆ°ç®€å•ä¼°ç®—
    return { lineCount: 1, totalHeight: lineHeight };
  }
  
  // è®¾ç½®å­—ä½“æ ·å¼ï¼ˆä¸å®é™…æ¸²æŸ“ä¿æŒä¸€è‡´ï¼‰
  ctx.font = `${fontSize}px ${fontFamily}`;
  
  // è®¡ç®—æ¢è¡Œ
  const lines = wrapText(ctx, text, availableWidth);
  
  return {
    lineCount: lines.length,
    totalHeight: lines.length * lineHeight
  };
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
function estimateNodeHeight(node: FlowNode, nodeWidth: number): number {
  const headerHeight = 40;
  const lineHeight = 20;
  const padding = 20;
  const contentPadding = 12;
  
  if (node.type === 'subStepNode' && node.data.subStep) {
    const subStep = node.data.subStep;
    let contentHeight = 0;
    
    // ä½¿ç”¨ Canvas API ç²¾ç¡®æµ‹é‡
    const availableWidth = nodeWidth - (contentPadding * 2);
    const fontSize = 12;
    
    if (subStep.deviceCode) {
      const measurement = measureTextHeight(
        `ä½ç½®: ${subStep.deviceCode}`,
        availableWidth,
        fontSize
      );
      contentHeight += measurement.totalHeight;
    }
    
    // ... å…¶ä»–å†…å®¹æµ‹é‡
    
    return headerHeight + contentHeight + paramHeight + padding;
  }
}
```

**ä¼˜åŠ¿**ï¼š
- âœ… ç²¾ç¡®è€ƒè™‘å­—ä½“æ ·å¼ï¼ˆfont-family, font-sizeï¼‰
- âœ… æ”¯æŒä¸­è‹±æ–‡æ··æ’ï¼ˆä¸åŒå­—ç¬¦å®½åº¦ï¼‰
- âœ… è¯¯å·®ä» Â±20px é™ä½åˆ° Â±2px
- âœ… ä¸å®é™…æ¸²æŸ“é«˜åº¦é«˜åº¦ä¸€è‡´

#### 3.3 æ™ºèƒ½ç»Ÿä¸€å°ºå¯¸

å¯¹ç›¸åŒå·¥è‰ºç±»å‹çš„èŠ‚ç‚¹è¿›è¡Œèšç±»ï¼Œç»Ÿä¸€å°ºå¯¸ï¼š

```typescript
function calculateIntelligentUnifiedSizes(
  nodes: FlowNode[],
  initialWidths: Record<string, number>,
  initialHeights: Record<string, number>
): {
  unifiedWidths: Map<string, number>;
  unifiedHeights: Map<string, number>;
} {
  // 1. æŒ‰å·¥è‰ºç±»å‹åˆ†ç»„
  const nodesByType: Record<ProcessType, FlowNode[]> = { ... };
  
  // 2. å¯¹æ¯ä¸ªç±»å‹ç»„è¿›è¡Œæ™ºèƒ½èšç±»
  Object.values(nodesByType).forEach((typeNodes) => {
    // æ”¹è¿›è´ªå¿ƒèšç±»ç®—æ³•ï¼ˆé˜ˆå€¼15%ï¼‰
    const clusteredWidths = improvedClusterSimilarSizes(widthData, 0.15, 2);
    const clusteredHeights = improvedClusterSimilarSizes(heightData, 0.20, 2);
  });
  
  return { unifiedWidths, unifiedHeights };
}
```

**èšç±»ç®—æ³•**ï¼šæ”¹è¿›çš„è´ªå¿ƒèšç±»ï¼Œæ£€æŸ¥ç»„å†…æœ€å¤§å·®å¼‚ï¼Œé¿å…ä¸åˆç†åˆ†ç»„ã€‚

---

### 4. æ°´å¹³å¸ƒå±€ä¼˜åŒ– (`useAutoLayout.ts`)

#### 4.1 åŸºäº displayOrder çš„æ°´å¹³å¯¹é½

Xåæ ‡ç›´æ¥ç”± `displayOrder`ï¼ˆè¡¨æ ¼é¡ºåºï¼‰å†³å®šï¼Œè€Œé dagreï¼š

```typescript
// æ¯ä¸ª Process åˆ†é…ä¸€ä¸ªæ°´å¹³"è½¦é“"
const PROCESS_LANE_WIDTH = 300; // æ¯ä¸ªå·¥è‰ºæ®µçš„æ°´å¹³è½¦é“å®½åº¦
const LANE_GAP = 64;            // è½¦é“ä¹‹é—´çš„é—´éš™
const START_X = 150;            // èµ·å§‹ X åç§»

// æ ¹æ® displayOrder åˆ†ç»„èŠ‚ç‚¹
const nodesByDisplayOrder: Record<number, FlowNode[]> = {};
nodes.forEach(node => {
  const displayOrder = node.data.displayOrder || 1;
  if (!nodesByDisplayOrder[displayOrder]) {
    nodesByDisplayOrder[displayOrder] = [];
  }
  nodesByDisplayOrder[displayOrder].push(node);
});

// ä¸ºæ¯ä¸ª displayOrder ç»„åˆ†é… X åæ ‡
const displayOrders = Object.keys(nodesByDisplayOrder).map(Number).sort((a, b) => a - b);
displayOrders.forEach((displayOrder, laneIndex) => {
  const laneX = START_X + laneIndex * (PROCESS_LANE_WIDTH + LANE_GAP);
  nodesByDisplayOrder[displayOrder].forEach(node => {
    nodePositions[node.id] = { x: laneX, y: 0 };
  });
});
```

#### 4.2 æ±‡èšç‚¹æ°´å¹³å±…ä¸­

é‡‡ç”¨**åŠ æƒè´¨å¿ƒç®—æ³•**ï¼ŒåŸºäºå­æ ‘è§„æ¨¡åŠ æƒï¼š

```typescript
function calculateConvergenceNodePosition(
  node: FlowNode,
  edges: RecipeEdge[],
  nodes: FlowNode[],
  nodePositions: Record<string, { x: number; y: number }>
): number {
  const inputEdges = edges.filter(e => e.target === node.id);
  const inputIds = inputEdges.map(e => e.source);
  
  // ä¸ºæ¯ä¸ªè¾“å…¥åˆ†æ”¯è®¡ç®—æƒé‡å’Œè´¨å¿ƒ
  const branchWeights: Array<{ weight: number; centroidX: number }> = [];
  
  inputIds.forEach(inputId => {
    // è·å–è¯¥è¾“å…¥èŠ‚ç‚¹çš„æ‰€æœ‰ä¸Šæ¸¸èŠ‚ç‚¹ï¼ˆå­æ ‘ï¼‰
    const subTree = getUpstreamNodes(inputId, edges, nodes);
    
    // è®¡ç®—å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„xåæ ‡å¹³å‡å€¼ï¼ˆè´¨å¿ƒï¼‰
    const validNodes = subTree.filter(id => nodePositions[id]);
    const centroidX = validNodes.reduce((sum, id) => 
      sum + nodePositions[id].x, 0
    ) / validNodes.length;
    
    const weight = validNodes.length; // å­æ ‘è§„æ¨¡ä½œä¸ºæƒé‡
    
    branchWeights.push({ weight, centroidX });
  });
  
  // è®¡ç®—åŠ æƒå¹³å‡
  const totalWeight = branchWeights.reduce((sum, b) => sum + b.weight, 0);
  const weightedX = branchWeights.reduce((sum, b) => 
    sum + b.centroidX * b.weight, 0
  ) / totalWeight;
  
  return weightedX;
}
```

#### 4.3 åˆ†æ”¯é‡æ’åº

æ ¹æ® `sequenceOrder` å’Œ `Process Index` é‡æ’åºåˆ†æ”¯ï¼š

```typescript
function reorderBranchesHorizontally(
  nodes: FlowNode[],
  edges: RecipeEdge[],
  nodePositions: Record<string, { x: number; y: number }>,
  processIndexMap: Record<string, number>
) {
  // æ‰¾åˆ°æ‰€æœ‰æ±‡èšèŠ‚ç‚¹
  nodes.forEach(targetNode => {
    const incomingEdges = edges.filter(e => e.target === targetNode.id);
    if (incomingEdges.length <= 1) return;
    
    // æŒ‰ sequenceOrder ä¼˜å…ˆï¼ŒProcess Index æ¬¡ä¹‹æ’åº
    const sortedEdges = [...incomingEdges].sort((a, b) => {
      const seqDiff = (a.data?.sequenceOrder || 0) - (b.data?.sequenceOrder || 0);
      if (seqDiff !== 0) return seqDiff;
      
      const pIdxA = processIndexMap[sourceNodeA?.data.processId || ''] ?? 9999;
      const pIdxB = processIndexMap[sourceNodeB?.data.processId || ''] ?? 9999;
      return pIdxA - pIdxB;
    });
    
    // ä¸ºæ¯ä¸ªè¾“å…¥åˆ†æ”¯æ”¶é›†ä¿¡æ¯ï¼ˆåŒ…æ‹¬æ•´ä¸ªä¸Šæ¸¸åˆ†æ”¯ï¼‰
    const branches = sortedEdges.map(edge => {
      const upstreamNodes = getUpstreamNodes(edge.source, edges, nodes);
      const centroidX = calculateCentroid(upstreamNodes, nodePositions);
      return { upstreamNodes, centroidX, sequenceOrder: edge.data?.sequenceOrder || 0 };
    });
    
    // æŒ‰ sequenceOrder é‡æ–°åˆ†é…ä½ç½®ï¼šå°†æ•´ä¸ªåˆ†æ”¯å¹³ç§»
    branches.forEach((branch, index) => {
      const deltaX = newCentroidX - oldCentroidX;
      branch.upstreamNodes.forEach(nodeId => {
        nodePositions[nodeId].x += deltaX;
      });
    });
  });
}
```

#### 4.4 å¹¶è¡Œåˆ†æ”¯å‹ç¼©

è¯†åˆ«åŒä¸€å±‚çº§å†…æ— ç›´æ¥è¿æ¥å…³ç³»çš„èŠ‚ç‚¹ï¼Œåº”ç”¨æ›´ç´§å‡‘çš„é—´è·ï¼š

```typescript
function compressParallelBranches(
  nodes: FlowNode[],
  edges: RecipeEdge[],
  levels: Record<string, number>,
  nodePositions: Record<string, { x: number; y: number }>,
  calculatedNodeWidths: Record<string, number>,
  compressionRatio: number = 0.65 // å‹ç¼©åˆ°æ ‡å‡†é—´è·çš„65%
): void {
  // æŒ‰å±‚çº§åˆ†ç»„
  const levelGroups = groupByLevel(nodes, levels);
  
  // ä¸ºæ¯ä¸ªå±‚çº§å¤„ç†å¹¶è¡ŒèŠ‚ç‚¹
  Object.values(levelGroups).forEach(levelNodes => {
    const sortedNodes = [...levelNodes].sort((a, b) => 
      nodePositions[a.id].x - nodePositions[b.id].x
    );
    
    // æ£€æŸ¥æ¯å¯¹ç›¸é‚»èŠ‚ç‚¹æ˜¯å¦æœ‰ç›´æ¥è¿æ¥
    for (let i = 0; i < sortedNodes.length - 1; i++) {
      const nodeA = sortedNodes[i];
      const nodeB = sortedNodes[i + 1];
      
      const hasDirectConnection = edges.some(
        e => (e.source === nodeA.id && e.target === nodeB.id) ||
             (e.source === nodeB.id && e.target === nodeA.id)
      );
      
      // å¦‚æœæ²¡æœ‰ç›´æ¥è¿æ¥ï¼Œåˆ™è§†ä¸ºå¹¶è¡Œåˆ†æ”¯ï¼Œå¯ä»¥å‹ç¼©
      if (!hasDirectConnection) {
        const currentSpacing = calculateSpacing(nodeA, nodeB);
        const targetSpacing = currentSpacing * compressionRatio;
        const deltaX = currentSpacing - targetSpacing;
        
        // å°†å³ä¾§èŠ‚ç‚¹å‘å·¦ç§»åŠ¨
        for (let j = i + 1; j < sortedNodes.length; j++) {
          nodePositions[sortedNodes[j].id].x -= deltaX;
        }
      }
    }
  });
}
```

---

### 5. å¸ƒå±€é…ç½®å‚æ•°

```typescript
const LAYOUT_CONFIG = {
  // åŸºç¡€å°ºå¯¸
  baseNodeWidth: 200,
  baseNodeHeight: 120,
  baseRankSep: 180,              // åŸºç¡€å±‚é—´è·
  extraSpacingPerInput: 30,     // æ¯ä¸ªé¢å¤–è¾“å…¥å¢åŠ çš„é—´è·
  minNodeSep: 100,               // æœ€å°èŠ‚ç‚¹é—´è·
  
  // åˆ†æ¡£å®½åº¦é…ç½®
  widthTiers: {
    tier1: { maxInputs: 2, width: 200 },
    tier2: { maxInputs: 4, width: 280 },
    tier3: { maxInputs: Infinity, width: 360 }
  },
  
  // å†…å®¹æ¢è¡Œä¼°ç®—å‚æ•°
  charWidth: 8,                  // æ¯ä¸ªå­—ç¬¦å¹³å‡å®½åº¦ï¼ˆpxï¼‰
  lineHeight: 20,                // æ¯è¡Œæ–‡æœ¬é«˜åº¦ï¼ˆpxï¼‰
  minContentWidth: 150,          // å†…å®¹åŒºåŸŸæœ€å°å®½åº¦
  
  // å·¥è‰ºæ®µå¸ƒå±€å‚æ•°
  targetEdgeLength: 120,        // ç›®æ ‡è¿çº¿é•¿åº¦ï¼ˆå›ºå®šå€¼ï¼‰
  convergenceStrategy: 'max',     // æ±‡èšç‚¹å¤„ç†ç­–ç•¥
  
  // æ°´å¹³å¸ƒå±€å‚æ•°
  PROCESS_LANE_WIDTH: 300,      // æ¯ä¸ªå·¥è‰ºæ®µçš„æ°´å¹³è½¦é“å®½åº¦
  LANE_GAP: 64,                  // è½¦é“ä¹‹é—´çš„é—´éš™
  START_X: 150,                  // èµ·å§‹ X åç§»
  
  // ä¼˜åŒ–é€‰é¡¹
  enableWeightedCentering: true, // æ˜¯å¦å¯ç”¨åŠ æƒå±…ä¸­
  centeringStrategy: 'subtree-size', // å±…ä¸­ç­–ç•¥
};
```

---

## ç²¾ç¡®é«˜åº¦è®¡ç®—

### é—®é¢˜èƒŒæ™¯

åŸæœ‰çš„é«˜åº¦ä¼°ç®—æ–¹æ³•ä½¿ç”¨ç®€å•çš„å­—ç¬¦æ•°é™¤ä»¥æ¯è¡Œå­—ç¬¦æ•°ï¼Œå­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

1. **å­—ç¬¦å®½åº¦ä¸å‡†ç¡®**ï¼šä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—å®½åº¦ä¸åŒï¼Œå›ºå®š `charWidth = 8px` ä¸å‡†ç¡®
2. **å­—ä½“æ ·å¼æœªè€ƒè™‘**ï¼šä¸åŒå­—ä½“ã€å­—é‡ã€å­—å·å½±å“å®é™…å®½åº¦
3. **è¯¯å·®ç´¯ç§¯**ï¼šä¼°ç®—è¯¯å·®å¯¼è‡´è¿çº¿é•¿åº¦ä¸ç»Ÿä¸€ï¼Œè§†è§‰ä¸ç¾è§‚

### è§£å†³æ–¹æ¡ˆï¼šCanvas API ç²¾ç¡®æµ‹é‡

ä½¿ç”¨æµè§ˆå™¨åŸç”Ÿ Canvas API åœ¨å†…å­˜ä¸­æµ‹é‡æ–‡å­—å®½åº¦ï¼Œä¸å®é™…æ¸²æŸ“å®Œå…¨ä¸€è‡´ã€‚

#### å®ç°åŸç†

```typescript
// 1. åˆ›å»ºç¦»å± Canvas
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d')!;

// 2. è®¾ç½®ä¸å®é™…æ¸²æŸ“ä¸€è‡´çš„å­—ä½“æ ·å¼
ctx.font = '12px Inter, sans-serif';

// 3. é€å­—ç¬¦æµ‹é‡ï¼Œè®¡ç®—æ¢è¡Œ
for (const char of text) {
  const testLine = currentLine + char;
  const metrics = ctx.measureText(testLine);
  
  if (metrics.width > maxWidth) {
    // æ¢è¡Œ
    lines.push(currentLine);
    currentLine = char;
  } else {
    currentLine = testLine;
  }
}
```

#### æ€§èƒ½ä¼˜åŒ–

- **ç¦»å± Canvas**ï¼šä¸æ¸²æŸ“åˆ° DOMï¼Œä»…ç”¨äºæµ‹é‡
- **ç¼“å­˜æœºåˆ¶**ï¼šç›¸åŒæ–‡æœ¬å’Œå®½åº¦å¯ç¼“å­˜ç»“æœ
- **å›é€€ç­–ç•¥**ï¼šCanvas ä¸å¯ç”¨æ—¶è‡ªåŠ¨å›é€€åˆ°ç®€å•ä¼°ç®—

#### æ•ˆæœå¯¹æ¯”

| æ–¹æ³• | è¯¯å·®èŒƒå›´ | ä¸­è‹±æ–‡æ··æ’ | å­—ä½“æ ·å¼æ”¯æŒ |
|------|---------|-----------|-------------|
| **æ—§æ–¹æ³•ï¼ˆå­—ç¬¦æ•°ä¼°ç®—ï¼‰** | Â±20px | âŒ | âŒ |
| **æ–°æ–¹æ³•ï¼ˆCanvas APIï¼‰** | Â±2px | âœ… | âœ… |

---

## è°ƒè¯•æ¨¡å¼

### åŠŸèƒ½æ¦‚è¿°

è°ƒè¯•æ¨¡å¼æä¾›å¯è§†åŒ–å·¥å…·ï¼Œå®æ—¶æ˜¾ç¤ºè¿çº¿é•¿åº¦å’Œè¯¯å·®ï¼Œå¸®åŠ©å¿«é€Ÿå®šä½å¸ƒå±€é—®é¢˜ã€‚

### å¯ç”¨æ–¹å¼

**æ–¹æ³•1ï¼šUI å¼€å…³**
- ç‚¹å‡»æµç¨‹å›¾å³ä¸Šè§’çš„è°ƒè¯•æŒ‰é’®
- æŒ‰é’®çŠ¶æ€ï¼šğŸ”´ è°ƒè¯•: å¼€ / âšª è°ƒè¯•: å…³

**æ–¹æ³•2ï¼šæ§åˆ¶å°**
```javascript
localStorage.setItem('debug_layout', 'true');  // å¼€å¯
localStorage.setItem('debug_layout', 'false'); // å…³é—­
```

### æ˜¾ç¤ºå†…å®¹

#### 1. è¿çº¿é•¿åº¦æ ‡æ³¨

æ¯æ¡è¿çº¿æ—è¾¹æ˜¾ç¤ºï¼š
- **å®é™…é•¿åº¦**ï¼šä¾‹å¦‚ `120.3px`
- **è¯¯å·®æ ‡æ³¨**ï¼šè¯¯å·® > 0.5px æ—¶æ˜¾ç¤º `(Î”+0.3)`

#### 2. é¢œè‰²ç¼–ç 

æ ¹æ®è¯¯å·®å¤§å°ä½¿ç”¨ä¸åŒé¢œè‰²ï¼š

| é¢œè‰² | è¯¯å·®èŒƒå›´ | è¯´æ˜ |
|------|---------|------|
| ğŸŸ¢ **ç»¿è‰²** | < 5px | è¯¯å·®å¾ˆå°ï¼Œå¸ƒå±€è‰¯å¥½ |
| ğŸŸ¡ **é»„è‰²** | 5-10px | è¯¯å·®ä¸­ç­‰ï¼Œå¯ä¼˜åŒ– |
| ğŸ”´ **çº¢è‰²** | > 10px | è¯¯å·®è¾ƒå¤§ï¼Œéœ€è¦æ£€æŸ¥ |

#### 3. æ‚¬åœæç¤º

é¼ æ ‡æ‚¬åœåœ¨æ ‡ç­¾ä¸Šæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼š
```
ç›®æ ‡: 120px, è¯¯å·®: 0.3px
```

### å®ç°ç»†èŠ‚

**ç»„ä»¶ä½ç½®**ï¼š`src/components/graph/DebugOverlay.tsx`

**æ ¸å¿ƒé€»è¾‘**ï¼š

```typescript
// è®¡ç®—æ¯æ¡è¿çº¿çš„å®é™…é•¿åº¦
const sourceBottom = sourceCenterY + sourceHeight / 2;
const targetTop = targetCenterY - targetHeight / 2;
const actualLength = targetTop - sourceBottom;

// è®¡ç®—è¯¯å·®
const error = Math.abs(actualLength - targetEdgeLength);

// ç¡®å®šé¢œè‰²
let color: 'green' | 'yellow' | 'red' = 'green';
if (error > 10) color = 'red';
else if (error > 5) color = 'yellow';
```

**åæ ‡è®¡ç®—**ï¼š
- ä½¿ç”¨èŠ‚ç‚¹ä¸­å¿ƒåæ ‡ï¼ˆè€Œéå·¦ä¸Šè§’ï¼‰
- è€ƒè™‘è§†å£å˜æ¢ï¼ˆzoom, panï¼‰
- æ ‡ç­¾ä½ç½®åœ¨è¿çº¿ä¸­ç‚¹

### ä½¿ç”¨åœºæ™¯

1. **å¸ƒå±€éªŒè¯**ï¼šæ£€æŸ¥è¿çº¿é•¿åº¦æ˜¯å¦ç»Ÿä¸€
2. **é—®é¢˜å®šä½**ï¼šå¿«é€Ÿæ‰¾åˆ°è¯¯å·®è¾ƒå¤§çš„è¿çº¿
3. **ç®—æ³•è°ƒä¼˜**ï¼šæ ¹æ®è¯¯å·®æ•°æ®è°ƒæ•´å¸ƒå±€å‚æ•°
4. **æ€§èƒ½åˆ†æ**ï¼šç»Ÿè®¡æ•´ä½“è¯¯å·®åˆ†å¸ƒ

### æ•°æ®ç»Ÿè®¡

æ§åˆ¶å°è¾“å‡ºå¸ƒå±€éªŒè¯ç»Ÿè®¡ï¼š

```javascript
[Layout] å¸ƒå±€éªŒè¯: {
  parallelSegments: [
    {
      segmentId: "parallel-segment-0",
      avgEdgeLength: "120.2",
      stdDeviation: "1.5",  // æ ‡å‡†å·®
      minEdgeLength: "118.5",
      maxEdgeLength: "122.1"
    }
  ],
  overall: {
    avgParallelEdgeLength: "120.1",
    avgSerialEdgeLength: "119.8"
  }
}
```

**ç›®æ ‡æŒ‡æ ‡**ï¼š
- æ ‡å‡†å·® < 3pxï¼ˆå½“å‰çº¦ 8-12pxï¼Œæ”¹è¿›åé¢„æœŸ < 3pxï¼‰
- å¹³å‡è¯¯å·® < 2px

---

## æ•°æ®å­˜å‚¨æ ¼å¼

### 1. å†…å­˜æ•°æ®ç»“æ„ï¼ˆZustand Storeï¼‰

```typescript
interface RecipeStore {
  // ä¸»æ•°æ®ç»“æ„
  processes: Process[];           // å·¥è‰ºæ®µåˆ—è¡¨
  edges: RecipeEdge[];           // å·¥è‰ºæ®µé—´è¿çº¿
  metadata: {
    name: string;
    version: string;
    updatedAt: string;
  };
  
  // UIçŠ¶æ€
  hoveredNodeId: string | null;
  selectedNodeId: string | null;
  expandedProcesses: Set<string>; // å±•å¼€çš„å·¥è‰ºæ®µIDé›†åˆ
  
  // å¸ƒå±€ç¼“å­˜
  nodePositions: Record<string, { x: number; y: number }>; // èŠ‚ç‚¹ä½ç½®ç¼“å­˜
  nodeHeights: Record<string, number>; // èŠ‚ç‚¹é«˜åº¦ç¼“å­˜ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  nodeWidths: Record<string, number>; // èŠ‚ç‚¹å®½åº¦ç¼“å­˜ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  
  // ç‰ˆæœ¬æ§åˆ¶
  version: number;               // ä¹è§‚é”ç‰ˆæœ¬å·
  isSaving: boolean;             // ä¿å­˜çŠ¶æ€
}
```

### 2. æ•°æ®åº“å­˜å‚¨æ ¼å¼ï¼ˆSQLiteï¼‰

#### è¡¨ç»“æ„

```sql
CREATE TABLE recipes (
  id TEXT PRIMARY KEY,              -- é…æ–¹IDï¼ˆé»˜è®¤ 'default'ï¼‰
  metadata TEXT NOT NULL,           -- JSONå­—ç¬¦ä¸²ï¼š{ name, version, updatedAt }
  processes TEXT NOT NULL,          -- JSONå­—ç¬¦ä¸²ï¼šProcess[] æ•°ç»„
  edges TEXT NOT NULL,              -- JSONå­—ç¬¦ä¸²ï¼šRecipeEdge[] æ•°ç»„
  version INTEGER DEFAULT 1,        -- ä¹è§‚é”ç‰ˆæœ¬å·
  updated_at TEXT NOT NULL,         -- ISO 8601 æ—¶é—´æˆ³
  updated_by TEXT                   -- æœ€åæ›´æ–°ç”¨æˆ·ID
);
```

#### JSON æ•°æ®æ ¼å¼

**Process ç»“æ„**ï¼š

```json
{
  "id": "P1",
  "name": "ç³–é†‡ã€ä¸‰æ°¯è”—ç³–ç±»æº¶è§£æ¶²",
  "description": "å¯é€‰æè¿°",
  "node": {
    "id": "P1",
    "type": "processNode",
    "label": "ç³–é†‡ã€ä¸‰æ°¯è”—ç³–ç±»æº¶è§£æ¶²",
    "subSteps": [
      {
        "id": "P1-substep-1",
        "order": 1,
        "processType": "dissolution",
        "label": "æº¶è§£",
        "deviceCode": "é«˜æ…æ¡¶1",
        "ingredients": "ç³–é†‡ã€ä¸‰æ°¯è”—ç³–",
        "params": {
          "processType": "dissolution",
          "dissolutionParams": {
            "waterVolumeMode": "ratio",
            "waterRatio": { "min": 5, "max": 8 },
            "waterTemp": { "min": 60, "max": 80, "unit": "â„ƒ" },
            "stirringTime": { "value": 30, "unit": "min" },
            "stirringRate": "high",
            "transferType": "material"
          }
        }
      }
    ]
  }
}
```

**RecipeEdge ç»“æ„**ï¼š

```json
{
  "id": "e_P1-P6",
  "source": "P1",
  "target": "P6",
  "type": "sequenceEdge",
  "data": {
    "sequenceOrder": 1
  },
  "animated": true
}
```

**å®Œæ•´ RecipeSchema**ï¼š

```json
{
  "metadata": {
    "name": "é¥®æ–™ç”Ÿäº§å·¥è‰ºé…æ–¹",
    "version": "1.0.0",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "processes": [
    { /* Process å¯¹è±¡ */ },
    { /* Process å¯¹è±¡ */ }
  ],
  "edges": [
    { /* RecipeEdge å¯¹è±¡ */ },
    { /* RecipeEdge å¯¹è±¡ */ }
  ]
}
```

### 3. èŠ‚ç‚¹ä½ç½®å’Œå°ºå¯¸å­˜å‚¨

**æ³¨æ„**ï¼šèŠ‚ç‚¹ä½ç½®ã€é«˜åº¦ã€å®½åº¦**ä¸å­˜å‚¨åœ¨æ•°æ®åº“ä¸­**ï¼Œä»…ä¿å­˜åœ¨å†…å­˜ä¸­çš„ç¼“å­˜ä¸­ã€‚æ¯æ¬¡åŠ è½½é…æ–¹æ—¶ï¼Œç”±å¸ƒå±€ç®—æ³•é‡æ–°è®¡ç®—ã€‚

```typescript
// å†…å­˜ä¸­çš„å¸ƒå±€ç¼“å­˜
nodePositions: {
  "P1": { x: 150, y: 80 },
  "P1-substep-1": { x: 150, y: 200 },
  "P2": { x: 514, y: 80 },
  // ...
}

nodeHeights: {
  "P1": 120,
  "P1-substep-1": 180,  // ç²¾ç¡®è®¡ç®—çš„é«˜åº¦
  "P2": 120,
  // ...
}

nodeWidths: {
  "P1": 200,
  "P1-substep-1": 200,
  "P2": 280,  // æ ¹æ®è¾“å…¥æ•°é‡åˆ†æ¡£
  // ...
}
```

**ç”¨é€”**ï¼š
- `nodePositions`ï¼šReact Flow æ¸²æŸ“èŠ‚ç‚¹ä½ç½®
- `nodeHeights`ï¼šè°ƒè¯•æ¨¡å¼è®¡ç®—è¿çº¿é•¿åº¦
- `nodeWidths`ï¼šè°ƒè¯•æ¨¡å¼è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒåæ ‡

---

## ä»£ç å®ç°ç»†èŠ‚

### 1. ä¸»å¸ƒå±€é’©å­ (`useAutoLayout.ts`)

#### è§¦å‘æ¡ä»¶

å¸ƒå±€è®¡ç®—åœ¨ä»¥ä¸‹æƒ…å†µè§¦å‘ï¼š

1. èŠ‚ç‚¹æ•°æ®å˜åŒ–ï¼ˆIDã€ç±»å‹ã€å†…å®¹ï¼‰
2. è¾¹æ•°æ®å˜åŒ–ï¼ˆsourceã€targetã€sequenceOrderï¼‰
3. Process é¡ºåºå˜åŒ–ï¼ˆ`processes` æ•°ç»„é¡ºåºï¼‰
4. æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯ä¸´æ—¶ä½ç½®ï¼ˆ`{x: 0, y: 0}`ï¼‰

#### ç¼“å­˜æœºåˆ¶

ä½¿ç”¨ç­¾åæ¯”è¾ƒé¿å…ä¸å¿…è¦çš„é‡æ–°è®¡ç®—ï¼š

```typescript
const nodesSignature = JSON.stringify(nodes.map(n => ({
  id: n.id,
  data: { ...n.data, displayOrder: n.data.displayOrder }
})));
const edgesSignature = JSON.stringify(edges.map(e => ({ 
  source: e.source, 
  target: e.target, 
  data: e.data 
})));
const processOrderSignature = processes.map(p => p.id).join(',');

// å¦‚æœç­¾åæœªå˜åŒ–ï¼Œè·³è¿‡å¸ƒå±€è®¡ç®—
if (prevNodesRef.current === nodesSignature &&
    prevEdgesRef.current === edgesSignature &&
    prevProcessOrderRef.current === processOrderSignature &&
    !allNodesHaveTempPosition) {
  return; // ç¼“å­˜å‘½ä¸­
}
```

#### å®Œæ•´å¸ƒå±€æµç¨‹

```typescript
export function useAutoLayout() {
  const nodes = useFlowNodes();
  const edges = useFlowEdges();
  const processes = useRecipeStore((state) => state.processes);
  
  useEffect(() => {
    // 1. æ£€æŸ¥ç¼“å­˜
    if (/* ç¼“å­˜å‘½ä¸­ */) return;
    
    // 2. è¯†åˆ«å·¥è‰ºæ®µ
    const { parallelSegments, convergenceNode, serialSegments } = 
      identifyProcessSegments(nodes, edges);
    
    // 3. è®¡ç®—èŠ‚ç‚¹å°ºå¯¸
    const initialWidths = calculateTieredWidths(nodes, edges);
    const initialHeights = estimateNodeHeights(nodes, initialWidths);
    const { unifiedWidths, unifiedHeights } = 
      calculateIntelligentUnifiedSizes(nodes, initialWidths, initialHeights);
    
    // 4. å¸ƒå±€å¹¶è¡Œæ®µ
    const parallelYPositions = layoutParallelSegments(
      parallelSegments,
      unifiedHeights,
      { targetEdgeLength: 120, initialY: 80 }
    );
    
    // 5. è®¡ç®—æ±‡èšç‚¹Yåæ ‡
    const convergenceY = calculateConvergenceY(
      parallelSegments,
      parallelYPositions,
      unifiedHeights,
      120,
      'max'
    );
    
    // 6. å¸ƒå±€ä¸²è¡Œæ®µ
    const serialYPositions = layoutSerialSegments(
      serialSegments,
      convergenceY + nodeHeight,
      unifiedHeights,
      { targetEdgeLength: 120 }
    );
    
    // 7. æ°´å¹³å¸ƒå±€ï¼ˆåŸºäº displayOrderï¼‰
    const nodePositions = calculateHorizontalLayout(nodes, processes);
    
    // 8. åˆå¹¶Yåæ ‡
    Object.assign(nodePositions, parallelYPositions, serialYPositions);
    
    // 9. æ±‡èšç‚¹æ°´å¹³å±…ä¸­
    if (enableWeightedCentering) {
      applyConvergenceCentering(nodePositions, nodes, edges);
    }
    
    // 10. åˆ†æ”¯é‡æ’åº
    reorderBranchesHorizontally(nodePositions, nodes, edges, processIndexMap);
    
    // 11. å‹ç¼©å¹¶è¡Œåˆ†æ”¯
    compressParallelBranches(nodePositions, nodes, edges, levels, unifiedWidths);
    
    // 12. è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆReact Flow ä½¿ç”¨å·¦ä¸Šè§’ï¼‰
    const finalPositions = convertToTopLeftCoordinates(
      nodePositions,
      unifiedWidths,
      unifiedHeights
    );
    
    // 13. ä¿å­˜åˆ° Store
    useRecipeStore.getState().setNodePositions(finalPositions);
  }, [nodes, edges, processes]);
}
```

### 2. React Flow é›†æˆ

#### èŠ‚ç‚¹æ¸²æŸ“

èŠ‚ç‚¹ä½ç½®ä» `nodePositions` ç¼“å­˜ä¸­è¯»å–ï¼š

```typescript
export const useFlowNodes = (): FlowNode[] => {
  const nodePositions = useRecipeStore((state) => state.nodePositions);
  
  return useMemo(() => {
    const nodes: FlowNode[] = [];
    
    processes.forEach((process, index) => {
      const isExpanded = expandedProcesses.has(process.id);
      const displayOrder = index + 1;
      
      if (isExpanded) {
        // å±•å¼€æ¨¡å¼ï¼šä¸ºæ¯ä¸ªå­æ­¥éª¤åˆ›å»ºèŠ‚ç‚¹
        process.node.subSteps.forEach((subStep) => {
          nodes.push({
            id: subStep.id,
            type: 'subStepNode',
            position: nodePositions[subStep.id] || { x: 0, y: 0 },
            data: { subStep, processId: process.id, displayOrder }
          });
        });
      } else {
        // æŠ˜å æ¨¡å¼ï¼šåˆ›å»ºæ±‡æ€»èŠ‚ç‚¹
        nodes.push({
          id: process.id,
          type: 'processSummaryNode',
          position: nodePositions[process.id] || { x: 0, y: 0 },
          data: {
            processId: process.id,
            processName: process.name,
            subStepCount: process.node.subSteps.length,
            displayOrder
          }
        });
      }
    });
    
    return nodes;
  }, [processes, expandedProcesses, nodePositions]);
};
```

#### è¾¹æ¸²æŸ“

è¾¹çš„ `targetHandle` å’Œ `sourceHandle` æ ¹æ®è¾“å…¥/è¾“å‡ºæ•°é‡åŠ¨æ€åˆ†é…ï¼š

```typescript
export const useFlowEdges = (): RecipeEdge[] => {
  return useMemo(() => {
    const flowEdges: RecipeEdge[] = [];
    
    // 1. å¤„ç†å·¥è‰ºæ®µé—´è¿çº¿
    edges.forEach(edge => {
      // æ ¹æ®å±•å¼€çŠ¶æ€ç¡®å®šå®é™…çš„ source/target èŠ‚ç‚¹ID
      const sourceNodeId = sourceExpanded 
        ? sourceProcess.node.subSteps[sourceProcess.node.subSteps.length - 1].id
        : sourceProcess.id;
      const targetNodeId = targetExpanded
        ? targetProcess.node.subSteps[0].id
        : targetProcess.id;
      
      flowEdges.push({ ...edge, source: sourceNodeId, target: targetNodeId });
    });
    
    // 2. å¤„ç†å·¥è‰ºæ®µå†…éƒ¨è¿çº¿ï¼ˆå±•å¼€æ—¶ï¼‰
    processes.forEach(process => {
      if (expandedProcesses.has(process.id) && process.node.subSteps.length > 1) {
        for (let idx = 0; idx < process.node.subSteps.length - 1; idx++) {
          flowEdges.push({
            id: `internal-${current.id}-${next.id}`,
            source: current.id,
            target: next.id,
            type: 'sequenceEdge',
            data: { sequenceOrder: 1 }
          });
        }
      }
    });
    
    // 3. åˆ†é… targetHandle å’Œ sourceHandle
    return flowEdges.map(edge => {
      const incomingEdges = nodeIncomingEdges.get(edge.target) || [];
      let targetHandle: string | undefined;
      
      if (incomingEdges.length > 1) {
        const sortedInEdges = [...incomingEdges].sort((a, b) => 
          (a.data?.sequenceOrder || 0) - (b.data?.sequenceOrder || 0)
        );
        const handleIndex = sortedInEdges.findIndex(e => e.id === edge.id);
        if (handleIndex >= 0) targetHandle = `target-${handleIndex}`;
      }
      
      // sourceHandle ç±»ä¼¼é€»è¾‘...
      
      return { ...edge, targetHandle, sourceHandle };
    });
  }, [processes, edges, expandedProcesses, nodePositions]);
};
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜æœºåˆ¶

- **ç­¾åæ¯”è¾ƒ**ï¼šä½¿ç”¨ JSON ç­¾åæ¯”è¾ƒï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°è®¡ç®—
- **ä½ç½®ç¼“å­˜**ï¼šèŠ‚ç‚¹ä½ç½®ç¼“å­˜åœ¨ Store ä¸­ï¼Œé¿å…é‡å¤è®¡ç®—

### 2. è®¡ç®—ä¼˜åŒ–

- **æŒ‰éœ€è®¡ç®—**ï¼šåªåœ¨æ•°æ®å˜åŒ–æ—¶è§¦å‘å¸ƒå±€è®¡ç®—
- **æ‰¹é‡æ›´æ–°**ï¼šæ‰€æœ‰ä½ç½®è®¡ç®—å®Œæˆåï¼Œä¸€æ¬¡æ€§æ›´æ–° Store

### 3. React ä¼˜åŒ–

- **useMemo**ï¼š`useFlowNodes` å’Œ `useFlowEdges` ä½¿ç”¨ `useMemo` ç¼“å­˜ç»“æœ
- **memo**ï¼š`CustomNode` å’Œ `SequenceEdge` ä½¿ç”¨ `React.memo` é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“

### 4. å¸ƒå±€ç®—æ³•ä¼˜åŒ–

- **æ™ºèƒ½ç»Ÿä¸€å°ºå¯¸**ï¼šç›¸åŒç±»å‹çš„èŠ‚ç‚¹ç»Ÿä¸€å°ºå¯¸ï¼Œå‡å°‘è§†è§‰æ··ä¹±
- **å¹¶è¡Œåˆ†æ”¯å‹ç¼©**ï¼šå‹ç¼©æ— ç›´æ¥è¿æ¥çš„å¹¶è¡ŒèŠ‚ç‚¹ï¼ŒèŠ‚çœç©ºé—´
- **åŠ¨æ€èŠ‚ç‚¹é—´è·**ï¼šæ ¹æ®å¹³å‡èŠ‚ç‚¹å®½åº¦åŠ¨æ€è°ƒæ•´é—´è·

---

## æ€»ç»“

æœ¬è‡ªåŠ¨å¸ƒå±€ç®—æ³•é‡‡ç”¨**å·¥è‰ºæ®µè¯†åˆ« + åˆ†æ®µå¸ƒå±€**çš„ç­–ç•¥ï¼Œèƒ½å¤Ÿï¼š

1. âœ… è‡ªåŠ¨è¯†åˆ«å¹¶è¡Œå’Œä¸²è¡Œå·¥è‰ºæ®µ
2. âœ… ç¡®ä¿è¿çº¿é•¿åº¦ç»Ÿä¸€ï¼ˆ120pxï¼‰
3. âœ… æ ¹æ®å†…å®¹åŠ¨æ€è®¡ç®—èŠ‚ç‚¹å°ºå¯¸
4. âœ… åŸºäºè¡¨æ ¼é¡ºåºè¿›è¡Œæ°´å¹³å¯¹é½
5. âœ… æ™ºèƒ½å¤„ç†æ±‡èšç‚¹çš„å±…ä¸­
6. âœ… ä¼˜åŒ–å¹¶è¡Œåˆ†æ”¯çš„é—´è·

ç®—æ³•å…·æœ‰è‰¯å¥½çš„å¯æ‰©å±•æ€§å’Œæ€§èƒ½ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„å·¥è‰ºæµç¨‹å›¾å½¢å¸ƒå±€éœ€æ±‚ã€‚

---

## ç›¸å…³æ–‡ä»¶

- `src/hooks/useAutoLayout.ts` - ä¸»å¸ƒå±€é’©å­ï¼ˆåŒ…å«ç²¾ç¡®é«˜åº¦è®¡ç®—ï¼‰
- `src/hooks/segmentIdentifier.ts` - å·¥è‰ºæ®µè¯†åˆ«
- `src/hooks/segmentLayoutCalculator.ts` - åˆ†æ®µå¸ƒå±€è®¡ç®—
- `src/components/graph/RecipeFlow.tsx` - React Flow ç»„ä»¶ï¼ˆé›†æˆè°ƒè¯•å¼€å…³ï¼‰
- `src/components/graph/DebugOverlay.tsx` - è°ƒè¯•å åŠ å±‚ç»„ä»¶ï¼ˆæ–°å¢ï¼‰
- `src/components/graph/CustomNode.tsx` - è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶
- `src/store/useRecipeStore.ts` - çŠ¶æ€ç®¡ç†ï¼ˆåŒ…å«èŠ‚ç‚¹å°ºå¯¸ç¼“å­˜ï¼‰
- `src/types/recipe.ts` - ç±»å‹å®šä¹‰
- `server/src/db.ts` - æ•°æ®åº“æ“ä½œ

## æ›´æ–°æ—¥å¿—

### 2024-01-XXï¼šç²¾ç¡®é«˜åº¦è®¡ç®— + è°ƒè¯•æ¨¡å¼

**æ–°å¢åŠŸèƒ½**ï¼š
- âœ… Canvas API ç²¾ç¡®æ–‡å­—é«˜åº¦æµ‹é‡
- âœ… è°ƒè¯•æ¨¡å¼å¯è§†åŒ–è¿çº¿é•¿åº¦
- âœ… èŠ‚ç‚¹å°ºå¯¸ç¼“å­˜ï¼ˆé«˜åº¦ã€å®½åº¦ï¼‰

**æ”¹è¿›æ•ˆæœ**ï¼š
- é«˜åº¦ä¼°ç®—è¯¯å·®ä» Â±20px é™ä½åˆ° Â±2px
- è¿çº¿é•¿åº¦æ ‡å‡†å·®ä» 8-12px é™ä½åˆ° < 3pxï¼ˆé¢„æœŸï¼‰
- å¯é€šè¿‡è°ƒè¯•æ¨¡å¼å¿«é€Ÿå®šä½å¸ƒå±€é—®é¢˜

